<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#050818" />
    <meta name="msapplication-TileColor" content="#0f172a" />
    <meta name="msapplication-TileImage" content="/icons/plex-donate-android-any-144.png" />
    <meta name="application-name" content="Plex Donate" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="Plex Donate" />
    <link rel="manifest" href="/manifest.webmanifest" />
    <link rel="icon" type="image/png" sizes="144x144" href="/icons/plex-donate-android-any-144.png" />
    <link rel="icon" type="image/png" sizes="192x192" href="/icons/plex-donate-android-any-192.png" />
    <link rel="icon" type="image/png" sizes="512x512" href="/icons/plex-donate-android-any-512.png" />
    <link rel="shortcut icon" href="/icons/plex-donate-android-any-144.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/icons/plex-donate-ios-120.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/icons/plex-donate-ios-152.png" />
    <link rel="apple-touch-icon" sizes="167x167" href="/icons/plex-donate-ios-167.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/plex-donate-ios-180.png" />

    <title>Plex Donate Dashboard</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI',
          sans-serif;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(
            120% 120% at 50% -10%,
            rgba(99, 102, 241, 0.35) 0%,
            rgba(15, 23, 42, 0.92) 45%,
            #050818 100%
          ),
          radial-gradient(80% 80% at 80% 20%, rgba(14, 165, 233, 0.18), transparent);
        color: #e2e8f0;
        display: flex;
        justify-content: center;
        padding: 32px 16px 64px;
        position: relative;
      }
      body::after {
        content: '';
        position: fixed;
        inset: 0;
        background: radial-gradient(
          60% 60% at 20% 20%,
          rgba(76, 29, 149, 0.18),
          transparent 70%
        );
        pointer-events: none;
        z-index: 0;
      }
      a {
        color: inherit;
      }
      h1,
      h2,
      h3 {
        margin: 0;
      }
      h1 {
        font-size: clamp(2.2rem, 4vw, 3rem);
        line-height: 1.1;
        background: linear-gradient(135deg, #c7d2fe 0%, #a855f7 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }
      h2 {
        font-size: clamp(1.4rem, 2vw, 1.8rem);
        line-height: 1.3;
      }
      p {
        margin: 0;
        line-height: 1.6;
      }
      .hidden {
        display: none !important;
      }
      .panel {
        width: min(780px, 100%);
        background: rgba(15, 23, 42, 0.82);
        border: 1px solid rgba(148, 163, 184, 0.3);
        border-radius: 20px;
        padding: 28px;
        text-align: center;
        box-shadow: 0 25px 60px -25px rgba(30, 64, 175, 0.6);
        position: relative;
        z-index: 1;
      }
      .panel.error {
        background: rgba(76, 29, 149, 0.18);
        border-color: rgba(248, 113, 113, 0.4);
        color: #fecdd3;
      }
      #app {
        width: min(960px, 100%);
        position: relative;
        z-index: 1;
      }
      .canvas {
        display: grid;
        gap: 28px;
      }
      .surface {
        background: rgba(15, 23, 42, 0.76);
        border: 1px solid rgba(148, 163, 184, 0.22);
        border-radius: 24px;
        padding: clamp(24px, 4vw, 36px);
        box-shadow: 0 30px 60px -28px rgba(37, 99, 235, 0.55);
        backdrop-filter: blur(18px);
      }
      .support-container {
        margin-top: 20px;
        display: grid;
        gap: 20px;
        text-align: left;
      }
      .support-wrapper {
        display: grid;
        gap: 24px;
      }
      .support-form {
        display: grid;
        gap: 12px;
      }
      .support-form label {
        font-size: 0.85rem;
        color: rgba(203, 213, 225, 0.85);
      }
      .support-form input,
      .support-form textarea {
        width: 100%;
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(15, 23, 42, 0.6);
        color: inherit;
        padding: 12px 14px;
        font-size: 1rem;
        font-family: inherit;
      }
      .support-form textarea {
        resize: vertical;
        min-height: 120px;
      }
      .support-actions {
        display: grid;
        gap: 12px;
      }
      .support-threads {
        display: grid;
        gap: 18px;
      }
      .support-thread-list {
        display: grid;
        gap: 10px;
      }
      .support-thread-button {
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 23, 42, 0.65);
        border-radius: 14px;
        padding: 14px 16px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        transition: border-color 0.15s ease, background 0.15s ease;
      }
      .support-thread-button:hover,
      .support-thread-button[aria-current='true'] {
        border-color: rgba(165, 180, 252, 0.6);
        background: rgba(79, 70, 229, 0.24);
      }
      .support-thread-button h3 {
        margin: 0;
        font-size: 1rem;
      }
      .support-status-pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }
      .support-status-open {
        background: rgba(34, 197, 94, 0.2);
        color: #bbf7d0;
      }
      .support-status-resolved {
        background: rgba(148, 163, 184, 0.2);
        color: rgba(226, 232, 240, 0.8);
      }
      .support-thread-detail {
        border: 1px solid rgba(148, 163, 184, 0.25);
        border-radius: 16px;
        padding: 18px;
        background: rgba(15, 23, 42, 0.5);
        display: grid;
        gap: 18px;
      }
      .support-messages {
        display: grid;
        gap: 12px;
        max-height: 320px;
        overflow-y: auto;
        padding-right: 4px;
      }
      .support-message {
        border-radius: 14px;
        border: 1px solid rgba(148, 163, 184, 0.25);
        padding: 12px 14px;
        background: rgba(30, 41, 59, 0.65);
        display: grid;
        gap: 6px;
      }
      .support-message[data-author='admin'] {
        border-color: rgba(129, 140, 248, 0.45);
        background: rgba(79, 70, 229, 0.28);
      }
      .support-message-author {
        font-weight: 600;
        font-size: 0.9rem;
      }
      .support-message-meta {
        font-size: 0.75rem;
        color: rgba(203, 213, 225, 0.7);
      }
      .support-empty {
        font-size: 0.9rem;
        color: rgba(203, 213, 225, 0.7);
      }
      .support-toggle {
        width: fit-content;
        justify-self: center;
      }
      .hero {
        position: relative;
        overflow: hidden;
        display: grid;
        gap: 16px;
        text-align: center;
      }
      .hero::after {
        content: '';
        position: absolute;
        inset: -40% 40% auto -30%;
        height: 120%;
        transform: rotate(18deg);
        background: radial-gradient(
          60% 60% at 50% 50%,
          rgba(59, 130, 246, 0.3),
          transparent 70%
        );
        z-index: 0;
      }
      .hero > * {
        position: relative;
        z-index: 1;
      }
      .eyebrow {
        letter-spacing: 0.2em;
        text-transform: uppercase;
        font-size: 0.75rem;
        color: rgba(165, 180, 252, 0.9);
      }
      .muted {
        color: rgba(203, 213, 225, 0.8);
      }
      .small {
        font-size: 0.85rem;
      }
      .status-text {
        font-size: 0.9rem;
        margin-top: 12px;
        color: rgba(165, 180, 252, 0.9);
      }
      .status-text.error {
        color: #fca5a5;
      }
      .status-text.success {
        color: #bbf7d0;
      }
      .status-text.info {
        color: #c7d2fe;
      }
      .link-inline {
        color: #c7d2fe;
        text-decoration: underline;
        font-weight: 600;
        cursor: pointer;
      }
      .link-inline:hover {
        text-decoration: none;
      }
      .announcement-banner {
        --announcement-bg: rgba(99, 102, 241, 0.22);
        --announcement-border: rgba(129, 140, 248, 0.45);
        --announcement-chip-bg: rgba(129, 140, 248, 0.35);
        --announcement-chip-color: #c7d2fe;
        --announcement-text: #e2e8f0;
        border-radius: 20px;
        border: 1px solid var(--announcement-border);
        padding: 20px;
        background: var(--announcement-bg);
        color: var(--announcement-text);
        box-shadow: 0 25px 50px -30px rgba(99, 102, 241, 0.8);
        display: grid;
        gap: 14px;
      }
      .announcement-banner[data-tone='success'] {
        --announcement-bg: rgba(34, 197, 94, 0.24);
        --announcement-border: rgba(74, 222, 128, 0.45);
        --announcement-chip-bg: rgba(74, 222, 128, 0.35);
        --announcement-chip-color: #bbf7d0;
      }
      .announcement-banner[data-tone='warning'] {
        --announcement-bg: rgba(234, 179, 8, 0.28);
        --announcement-border: rgba(250, 204, 21, 0.45);
        --announcement-chip-bg: rgba(250, 204, 21, 0.35);
        --announcement-chip-color: #fde68a;
      }
      .announcement-banner[data-tone='danger'] {
        --announcement-bg: rgba(248, 113, 113, 0.28);
        --announcement-border: rgba(252, 165, 165, 0.45);
        --announcement-chip-bg: rgba(252, 165, 165, 0.4);
        --announcement-chip-color: #fecdd3;
      }
      .announcement-banner[data-tone='neutral'] {
        --announcement-bg: rgba(71, 85, 105, 0.45);
        --announcement-border: rgba(148, 163, 184, 0.4);
        --announcement-chip-bg: rgba(148, 163, 184, 0.45);
        --announcement-chip-color: #e2e8f0;
      }
      .announcement-banner h2,
      .announcement-banner h3,
      .announcement-banner p {
        margin: 0;
      }
      .announcement-banner p {
        white-space: pre-wrap;
      }
      .announcement-banner-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      .announcement-chip {
        display: inline-flex;
        align-items: center;
        padding: 4px 12px;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        background: var(--announcement-chip-bg);
        color: var(--announcement-chip-color);
      }
      .announcement-dismiss {
        border: none;
        background: transparent;
        color: inherit;
        font-size: 0.85rem;
        opacity: 0.75;
        cursor: pointer;
      }
      .announcement-actions {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }
      .announcement-cta {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 10px 18px;
        border-radius: 999px;
        font-weight: 600;
        background: rgba(148, 163, 184, 0.25);
        color: inherit;
        text-decoration: none;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }
      .announcement-cta:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 30px -22px rgba(148, 163, 184, 0.8);
      }
      .login-footnote {
        margin: -6px 0 0;
      }
      .helper-text {
        color: rgba(203, 213, 225, 0.8);
        font-size: 0.9rem;
      }
      form {
        display: grid;
        gap: 16px;
        margin-top: 20px;
        text-align: left;
      }
      label {
        display: grid;
        gap: 8px;
        font-weight: 600;
        color: #cbd5f5;
      }
      input {
        width: 100%;
        padding: 12px 14px;
        border-radius: 12px;
        border: 1px solid rgba(129, 140, 248, 0.4);
        background: rgba(15, 23, 42, 0.7);
        color: inherit;
        font-size: 1rem;
      }
      input:focus {
        outline: 2px solid rgba(129, 140, 248, 0.8);
        outline-offset: 2px;
      }
      button {
        appearance: none;
        border: none;
        border-radius: 999px;
        padding: 12px 22px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }
      button:disabled {
        cursor: not-allowed;
        opacity: 0.6;
      }
      .button-link {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        border-radius: 999px;
        padding: 12px 22px;
        font-size: 1rem;
        font-weight: 600;
        text-decoration: none;
        transition: transform 0.2s ease, box-shadow 0.2s ease,
          opacity 0.2s ease;
      }
      .button-link:hover {
        transform: translateY(-1px);
      }
      .button-primary {
        background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
        color: #ffffff;
        box-shadow: 0 12px 30px -12px rgba(79, 70, 229, 0.65);
      }
      .button-secondary {
        background: rgba(148, 163, 184, 0.2);
        color: #e2e8f0;
        border: 1px solid rgba(148, 163, 184, 0.4);
      }
      .plex-link-controls {
        display: grid;
        gap: 12px;
        margin-top: 16px;
        justify-items: start;
        align-items: start;
      }
      .plex-link-controls .button-primary {
        width: fit-content;
      }
      .plex-link-pin {
        display: grid;
        gap: 6px;
        padding: 14px 18px;
        border-radius: 14px;
        background: rgba(79, 70, 229, 0.18);
        border: 1px solid rgba(165, 180, 252, 0.35);
        font-variant-numeric: tabular-nums;
        max-width: min(320px, 100%);
      }
      .plex-link-pin-code {
        font-size: 1.9rem;
        font-weight: 700;
        letter-spacing: 0.12em;
      }
      .plex-link-pin-expiry {
        font-size: 0.85rem;
        color: rgba(203, 213, 225, 0.85);
      }
      .header-actions {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
        align-items: center;
      }
      .grid {
        display: grid;
        gap: 24px;
      }
      @media (min-width: 900px) {
        .grid-columns-2 {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }
      .profile-summary {
        display: flex;
        justify-content: space-between;
        gap: 16px;
        flex-wrap: wrap;
        align-items: center;
      }
      .status-pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 14px;
        border-radius: 999px;
        font-size: 0.82rem;
        font-weight: 600;
        background: rgba(59, 130, 246, 0.24);
        color: #bfdbfe;
        text-transform: capitalize;
      }
      .status-pill[data-status='active'] {
        background: rgba(34, 197, 94, 0.22);
        color: #bbf7d0;
      }
      .status-pill[data-status='cancelled'],
      .status-pill[data-status='suspended'],
      .status-pill[data-status='expired'] {
        background: rgba(248, 113, 113, 0.24);
        color: #fecdd3;
      }
      .detail-list {
        display: grid;
        gap: 12px;
        margin-top: 20px;
      }
      .detail {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
        font-size: 0.95rem;
      }
      .detail .label {
        color: rgba(148, 163, 184, 0.9);
        font-weight: 600;
      }
      .invite-ready {
        margin-top: 24px;
        border-radius: 18px;
        border: 1px solid rgba(129, 140, 248, 0.4);
        padding: 18px;
        background: rgba(79, 70, 229, 0.15);
        text-align: left;
        display: grid;
        gap: 12px;
      }
      .invite-link {
        word-break: break-all;
        color: #c7d2fe;
        text-decoration: underline;
      }
      .badge {
        display: inline-flex;
        align-items: center;
        padding: 4px 10px;
        border-radius: 999px;
        font-weight: 600;
        font-size: 0.8rem;
      }
      .badge.success {
        background: rgba(34, 197, 94, 0.28);
        color: #bbf7d0;
      }
      .login-card {
        display: grid;
        gap: 16px;
        text-align: left;
      }
      .cta-actions {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
      }
      .subscription-cta {
        margin-top: 18px;
        display: grid;
        gap: 8px;
        justify-items: start;
      }
      .subscription-cta .button-primary {
        text-decoration: none;
        text-align: center;
      }
      .onboarding {
        display: grid;
        gap: 20px;
        text-align: left;
      }
      .request-list {
        margin: 16px 0;
        padding-left: 1.2rem;
        display: grid;
        gap: 8px;
      }
      .steps {
        display: grid;
        gap: 16px;
      }
      .step {
        border: 1px solid rgba(148, 163, 184, 0.28);
        border-radius: 20px;
        padding: 18px 20px;
        background: rgba(15, 23, 42, 0.66);
        transition: border-color 0.2s ease, box-shadow 0.2s ease,
          background 0.2s ease, transform 0.2s ease;
      }
      .step-header {
        display: flex;
        align-items: center;
        gap: 14px;
      }
      .step-header > div {
        display: grid;
        gap: 6px;
      }
      .step-number {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 40px;
        height: 40px;
        border-radius: 999px;
        background: rgba(99, 102, 241, 0.25);
        color: #c7d2fe;
        font-weight: 700;
        font-size: 1.1rem;
        flex-shrink: 0;
      }
      .step-title {
        margin: 0;
        font-size: 1.1rem;
        font-weight: 600;
      }
      .step-footnote {
        margin-top: 12px;
      }
      .step[data-state='complete'] {
        border-color: rgba(34, 197, 94, 0.45);
        background: rgba(21, 128, 61, 0.18);
      }
      .step[data-state='complete'] .step-number {
        background: rgba(34, 197, 94, 0.35);
        color: #bbf7d0;
      }
      .step[data-state='current'] {
        border-color: rgba(129, 140, 248, 0.8);
        background: rgba(79, 70, 229, 0.2);
        box-shadow: 0 18px 40px -28px rgba(99, 102, 241, 0.9);
        transform: translateY(-2px);
      }
      .step[data-state='current'] .step-number {
        background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
        color: #ffffff;
      }
      .step[data-state='upcoming'] {
        opacity: 0.92;
      }
      .step[data-state='upcoming'] .step-number {
        background: rgba(100, 116, 139, 0.25);
        color: rgba(203, 213, 225, 0.8);
      }
      .password-guidance {
        margin-top: -4px;
      }
      .section-title {
        font-size: 1.2rem;
        font-weight: 600;
      }
      ul {
        margin: 0;
        padding-left: 20px;
        display: grid;
        gap: 8px;
      }
    </style>
  </head>
  <body>
    <div id="loading" class="panel">Loading your dashboard…</div>
    <div id="error-panel" class="panel error hidden"></div>
    <div id="app" class="hidden">
      <main class="canvas">
        <section class="surface hero">
          <span class="eyebrow">Plex Donate</span>
          <h1>You're just steps away from endless Plex adventures</h1>
          <p class="muted">
            Signed up through one of our share links? Use the account you
            created there to manage invites, keep your details current, and
            jump back into your libraries anytime. Not subscribed yet? Follow
            the guided checklist below to unlock access to endless content.
          </p>
        </section>

        <section
          id="announcement-banner"
          class="announcement-banner hidden"
          role="status"
          aria-live="polite"
          data-tone="info"
        >
          <div class="announcement-banner-header">
            <span class="announcement-chip" id="announcement-chip">Information</span>
            <button
              type="button"
              class="announcement-dismiss"
              id="announcement-dismiss"
              aria-label="Dismiss announcement"
            >
              Dismiss
            </button>
          </div>
          <h2 id="announcement-title">Banner title</h2>
          <p id="announcement-body"></p>
          <div class="announcement-actions">
            <a
              id="announcement-cta"
              class="announcement-cta hidden"
              href="#"
              target="_blank"
              rel="noopener"
            ></a>
          </div>
        </section>

        <section id="login-panel" class="surface login-card">
          <div>
            <span class="section-title">Customer sign-in</span>
            <p class="muted small">
              Use the same credentials you saved on the invite page. If you're
              just getting started, head back to your share link to complete
              step one.
            </p>
          </div>
          <form id="login-form">
            <label>
              <span>Email on file</span>
              <input
                id="login-email"
                type="email"
                placeholder="you@example.com"
                autocomplete="email"
                required
              />
            </label>
            <label>
              <span>Password</span>
              <input
                id="login-password"
                type="password"
                placeholder="••••••••"
                autocomplete="current-password"
                required
              />
            </label>
            <div class="cta-actions">
              <button id="login-button" type="submit" class="button-primary">
                Sign in
              </button>
              <p id="login-status" class="status-text"></p>
            </div>
          </form>
          <p class="muted small login-footnote">
            <a
              id="forgot-password-link"
              class="link-inline"
              href="#"
              aria-controls="forgot-password-help"
              aria-expanded="false"
              >Forgot your password?</a
            >
          </p>
          <p id="forgot-password-help" class="muted small hidden helper-text">
            Donor accounts can request a fresh invite email from your share link
            to set a new password. Need a hand? Reach out to the server admin
            and they'll help you get back to streaming in no time.
          </p>
        </section>

        <section id="dashboard-panel" class="grid hidden">
          <article class="surface">
            <div class="profile-summary">
              <div>
                <h2 class="section-title">Your membership</h2>
                <p id="member-name" class="muted"></p>
                <p id="member-email" class="muted"></p>
              </div>
              <div class="header-actions">
                <span
                  id="member-status"
                  class="status-pill"
                  data-status="pending"
                  >pending</span
                >
                <button
                  id="change-password-button"
                  class="button-secondary"
                  type="button"
                >
                  Change password
                </button>
                <button id="logout-button" class="button-secondary" type="button">
                  Sign out
                </button>
              </div>
            </div>
            <div class="detail-list">
              <div id="member-plan" class="detail hidden"></div>
              <div id="member-subscription-row" class="detail hidden">
                <span class="label">Subscription ID</span>
                <span id="member-subscription-id"></span>
              </div>
              <div id="member-last-payment-row" class="detail hidden">
                <span class="label">Last payment</span>
                <span id="member-last-payment"></span>
              </div>
            </div>
            <p
              id="member-status-message"
              class="status-text small"
              aria-live="polite"
            ></p>
            <div id="subscription-cta" class="subscription-cta hidden">
              <button id="subscription-button" class="button-primary" type="button">
                Start PayPal subscription
              </button>
              <p id="subscription-note" class="status-text small">
                Opens PayPal checkout in a new tab.
              </p>
            </div>
          </article>

          <article id="onboarding-panel" class="surface onboarding hidden">
            <h2 class="section-title">Unlock endless content in three steps</h2>
            <p class="muted">
              You're only moments away from streaming everything you love.
              Follow the guided path below to complete your setup.
            </p>
            <p class="status-text info">
              <strong>
                Before continuing, create or recover your Plex account at
                <a href="https://www.plex.tv/sign-up/" target="_blank" rel="noopener"
                  >plex.tv</a
                > so you can link it here—checkout stays disabled until Plex is ready.
              </strong>
            </p>
            <div class="steps">
              <div id="step-plex" class="step" data-state="current">
                <div class="step-header">
                  <span class="step-number" data-step-number="1">1</span>
                  <div>
                    <h3 class="step-title">Authenticate with Plex</h3>
                    <p id="step-plex-note" class="muted small">
                      Use the button below to launch the Plex prompt and link
                      the account you use for streaming.
                    </p>
                  </div>
                </div>
                <p class="step-footnote muted small">
                  We rely on Plex to deliver the library—linking your account
                  keeps access seamless.
                </p>
                <div id="plex-link-controls" class="plex-link-controls">
                  <button id="plex-link-button" class="button-primary" type="button">
                    Link Plex account
                  </button>
                  <div
                    id="plex-link-pin"
                    class="plex-link-pin hidden"
                    aria-live="polite"
                  >
                    <span class="muted small">Use this PIN if Plex asks for it:</span>
                    <span id="plex-link-pin-code" class="plex-link-pin-code">----</span>
                    <span
                      id="plex-link-pin-expiry"
                      class="plex-link-pin-expiry"
                    ></span>
                  </div>
                  <p
                    id="plex-link-status"
                    class="status-text small"
                    aria-live="polite"
                  ></p>
                </div>
              </div>
              <div id="step-subscription" class="step" data-state="upcoming">
                <div class="step-header">
                  <span class="step-number" data-step-number="2">2</span>
                  <div>
                    <h3 class="step-title">Start your support subscription</h3>
                    <p id="step-subscription-note" class="muted small">
                      Once Plex is linked, use the PayPal button above to kick
                      off your membership.
                    </p>
                  </div>
                </div>
              </div>
              <div id="step-invite" class="step" data-state="upcoming">
                <div class="step-header">
                  <span class="step-number" data-step-number="3">3</span>
                  <div>
                    <h3 class="step-title">Share a referral invite</h3>
                    <p id="step-invite-note" class="muted small">
                      Send a referral invite each month to welcome someone new.
                      Lost your own library access? Regenerate your link here
                      when you’re eligible.
                    </p>
                  </div>
                </div>
              </div>
            </div>
          </article>

          <article class="surface">
            <h2 class="section-title">Update your profile</h2>
            <p class="muted">
              Keep your preferred streaming email and display name current so we
              can reach you when new invites are generated.
            </p>
            <form id="profile-form">
              <label>
                <span>Streaming email</span>
                <input
                  id="profile-email"
                  type="email"
                  placeholder="you@example.com"
                  autocomplete="email"
                  required
                />
              </label>
              <label>
                <span>Display name</span>
                <input
                  id="profile-name"
                  type="text"
                  placeholder="How should we greet you?"
                  autocomplete="name"
                />
              </label>
              <label>
                <span>PayPal subscription ID</span>
                <input
                  id="profile-subscription"
                  type="text"
                  placeholder="Starts with I-..."
                  autocomplete="off"
                  inputmode="text"
                  spellcheck="false"
                />
                <p class="helper-text">
                  Already supporting the server? Paste your PayPal subscription ID to
                  link it to this account.
                </p>
              </label>
              <div class="cta-actions">
                <button id="profile-save" type="submit" class="button-primary">
                  Save changes
                </button>
                <p id="profile-status" class="status-text"></p>
              </div>
            </form>
          </article>

          <article id="password-panel" class="surface">
            <h2 class="section-title">Password &amp; security</h2>
            <p id="password-guidance" class="muted small password-guidance">
              Update your dashboard password to keep your account secure.
            </p>
            <form id="password-form">
              <label id="password-current-row">
                <span>Current password</span>
                <input
                  id="password-current"
                  type="password"
                  placeholder="••••••••"
                  autocomplete="current-password"
                />
              </label>
              <label>
                <span>New password</span>
                <input
                  id="password-new"
                  type="password"
                  placeholder="Choose something memorable"
                  autocomplete="new-password"
                  required
                />
              </label>
              <label>
                <span>Confirm new password</span>
                <input
                  id="password-confirm"
                  type="password"
                  placeholder="Repeat your new password"
                  autocomplete="new-password"
                />
              </label>
              <div class="cta-actions">
                <button id="password-save" type="submit" class="button-primary">
                  Update password
                </button>
                <p id="password-status" class="status-text"></p>
              </div>
            </form>
          </article>

          <article class="surface">
            <h2 class="section-title">Your referral invites</h2>
            <p class="muted" id="invite-description">
              Active subscribers can share one referral invite each month. We'll
              highlight when the next referral unlocks. If you lost access,
              regenerate your personal link here once the cooldown ends.
            </p>
            <form id="invite-form">
              <label>
                <span>Email for this referral invite</span>
                <input
                  id="invite-email"
                  type="email"
                  placeholder="you@example.com"
                  autocomplete="email"
                  required
                />
              </label>
              <label>
                <span>Optional note for the recipient</span>
                <input
                  id="invite-note"
                  type="text"
                  placeholder="Used for tracking referral invites"
                />
              </label>
              <div class="cta-actions">
                <button id="invite-submit" type="submit" class="button-primary">
                  Send referral invite
                </button>
                <p id="invite-status" class="status-text"></p>
              </div>
            </form>
            <div id="invite-ready" class="invite-ready hidden">
              <span class="badge success">Referral invite ready</span>
              <a id="invite-link" class="invite-link" href="#" target="_blank" rel="noopener"></a>
              <p id="invite-email-display" class="muted small"></p>
              <p id="invite-created" class="muted small"></p>
            </div>
          </article>

          <article class="surface" id="support-panel">
            <h2 class="section-title">Need help?</h2>
            <p class="muted">
              Reach out to the Plex Donate team for account help or streaming
              questions. We’ll send updates to the email on your account.
            </p>
            <button id="support-toggle" type="button" class="button-link button-primary support-toggle">
              Contact support
            </button>
            <div id="support-container" class="support-container hidden">
              <div class="support-wrapper">
                <form id="support-form" class="support-form">
                  <div class="support-actions">
                    <label for="support-name">Your name or display name</label>
                    <input id="support-name" name="name" type="text" autocomplete="name" />
                  </div>
                  <div class="support-actions">
                    <label for="support-subject">Subject</label>
                    <input id="support-subject" name="subject" type="text" required />
                  </div>
                  <div class="support-actions">
                    <label for="support-message">Message</label>
                    <textarea id="support-message" name="message" rows="4" required></textarea>
                  </div>
                  <button id="support-submit" type="submit" class="button-link button-primary">
                    Send support request
                  </button>
                  <p id="support-status" class="status-text small"></p>
                </form>

                <div class="support-threads" id="support-threads">
                  <div class="support-thread-list" id="support-thread-list"></div>
                  <p id="support-empty" class="support-empty hidden">
                    You haven't opened any support requests yet.
                  </p>
                  <div id="support-thread-detail" class="support-thread-detail hidden">
                    <div class="support-thread-meta">
                      <h3 id="support-thread-subject"></h3>
                      <span id="support-thread-status" class="support-status-pill support-status-open">Open</span>
                    </div>
                    <div id="support-messages" class="support-messages"></div>
                    <form id="support-reply-form" class="support-form">
                      <label for="support-reply-message">Reply</label>
                      <textarea id="support-reply-message" rows="3" required></textarea>
                      <button id="support-reply-submit" type="submit" class="button-link button-primary">
                        Send reply
                      </button>
                      <p id="support-reply-status" class="status-text small"></p>
                    </form>
                  </div>
                </div>
              </div>
            </div>
          </article>

          <article class="surface hidden" id="overseerr-section">
            <h2 class="section-title">Request new content through Overseerr</h2>
            <p class="muted">
              Looking for a movie or show we don't have yet? Submit a request in
              Overseerr so the server team can queue it up for you.
            </p>
            <ol class="request-list muted small">
              <li>Sign in with your Plex account so requests stay linked.</li>
              <li>
                Search for the title you want and choose
                <strong>Request</strong> to send it to the admins.
              </li>
              <li>
                Visit the <strong>Activity</strong> tab to follow approvals and
                downloads once they're underway.
              </li>
            </ol>
            <a
              class="button-link button-primary"
              id="overseerr-link"
              href="#"
              aria-disabled="true"
            >
              Open Overseerr
            </a>
          </article>

          <article class="surface">
            <h2 class="section-title">Streaming libraries</h2>
            <p class="muted">
              Jump into your Plex library once your referral invite is accepted.
              Save the link below for quick access.
            </p>
            <ul>
              <li>
                <a href="https://app.plex.tv/" target="_blank" rel="noopener"
                  >Launch Plex</a
                >
              </li>
              <li class="muted small">
                Need another referral? Active supporters can send a new invite
                once the monthly cooldown resets—or regenerate their own link if
                they’ve lost access.
              </li>
            </ul>
          </article>
        </section>
      </main>
    </div>

    <script>
      const state = {
        data: null,
        inviteLimitReached: false,
        nextInviteAvailableAt: null,
        pendingPlexLink: null,
        announcement: null,
        support: {
          threads: [],
          activeThreadId: null,
          donorId: null,
        },
      };
      let inviteCooldownTimer = null;
      let inviteCooldownTimerType = null;
      let plexLinkPollTimer = null;
      let plexLinkCountdownTimer = null;
      let plexLinkCountdownExpiryMs = null;
      let plexLinkAuthWindow = null;
      let plexLinkStatusSticky = false;
      let supportPanelOpen = false;
      let supportLoading = false;
      let supportThreadsRequest = null;

      const loadingPanel = document.getElementById('loading');
      const errorPanel = document.getElementById('error-panel');
      const app = document.getElementById('app');
      const loginPanel = document.getElementById('login-panel');
      const dashboardPanel = document.getElementById('dashboard-panel');

      const loginForm = document.getElementById('login-form');
      const loginButton = document.getElementById('login-button');
      const loginStatus = document.getElementById('login-status');
      const loginPassword = document.getElementById('login-password');
      const loginEmail = document.getElementById('login-email');
      const forgotPasswordLink = document.getElementById('forgot-password-link');
      const forgotPasswordHelp = document.getElementById('forgot-password-help');
      const defaultForgotPasswordLinkText = forgotPasswordLink
        ? forgotPasswordLink.textContent
        : 'Forgot your password?';
      const announcementBanner = document.getElementById('announcement-banner');
      const announcementChip = document.getElementById('announcement-chip');
      const announcementTitle = document.getElementById('announcement-title');
      const announcementBody = document.getElementById('announcement-body');
      const announcementCta = document.getElementById('announcement-cta');
      const announcementDismissButton = document.getElementById('announcement-dismiss');

      const logoutButton = document.getElementById('logout-button');
      const memberNameEl = document.getElementById('member-name');
      const memberEmailEl = document.getElementById('member-email');
      const memberStatusEl = document.getElementById('member-status');
      const memberPlanEl = document.getElementById('member-plan');
      const memberSubscriptionRow = document.getElementById('member-subscription-row');
      const memberSubscriptionId = document.getElementById('member-subscription-id');
      const memberLastPaymentRow = document.getElementById('member-last-payment-row');
      const memberLastPayment = document.getElementById('member-last-payment');
      const subscriptionCta = document.getElementById('subscription-cta');
      const subscriptionButton = document.getElementById('subscription-button');
      const subscriptionNote = document.getElementById('subscription-note');
      const memberStatusMessage = document.getElementById('member-status-message');
      const plexLinkButton = document.getElementById('plex-link-button');
      const plexLinkStatus = document.getElementById('plex-link-status');
      const plexLinkPin = document.getElementById('plex-link-pin');
      const plexLinkPinCode = document.getElementById('plex-link-pin-code');
      const plexLinkPinExpiry = document.getElementById('plex-link-pin-expiry');
      const changePasswordButton = document.getElementById('change-password-button');
      const onboardingPanel = document.getElementById('onboarding-panel');
      const stepSubscription = document.getElementById('step-subscription');
      const stepPlex = document.getElementById('step-plex');
      const stepInvite = document.getElementById('step-invite');
      const stepSubscriptionNote = document.getElementById('step-subscription-note');
      const stepPlexNote = document.getElementById('step-plex-note');
      const stepInviteNote = document.getElementById('step-invite-note');
      const overseerrSection = document.getElementById('overseerr-section');
      const overseerrLink = document.getElementById('overseerr-link');
      const supportToggle = document.getElementById('support-toggle');
      const supportContainer = document.getElementById('support-container');
      const supportForm = document.getElementById('support-form');
      const supportNameInput = document.getElementById('support-name');
      const supportSubjectInput = document.getElementById('support-subject');
      const supportMessageInput = document.getElementById('support-message');
      const supportSubmit = document.getElementById('support-submit');
      const supportStatus = document.getElementById('support-status');
      const supportThreads = document.getElementById('support-threads');
      const supportThreadList = document.getElementById('support-thread-list');
      const supportThreadDetail = document.getElementById('support-thread-detail');
      const supportThreadSubject = document.getElementById('support-thread-subject');
      const supportThreadStatus = document.getElementById('support-thread-status');
      const supportMessages = document.getElementById('support-messages');
      const supportEmpty = document.getElementById('support-empty');
      const supportReplyForm = document.getElementById('support-reply-form');
      const supportReplyMessage = document.getElementById('support-reply-message');
      const supportReplyStatus = document.getElementById('support-reply-status');
      const supportReplySubmit = document.getElementById('support-reply-submit');
      const defaultSubscriptionButtonLabel = subscriptionButton
        ? subscriptionButton.textContent
        : 'Start PayPal subscription';
      if (subscriptionButton) {
        subscriptionButton.disabled = true;
        subscriptionButton.dataset.available = 'false';
      }

      const SESSION_TOKEN_QUERY_PARAM = 'session';
      const VERIFICATION_TOKEN_QUERY_PARAM = 'token';
      let sessionToken = null;
      let initialVerificationToken = null;
      let verificationInFlight = false;

      const ANNOUNCEMENT_TONE_LABELS = {
        info: 'Information',
        success: 'Success',
        warning: 'Warning',
        danger: 'Alert',
        neutral: 'Update',
      };
      const ANNOUNCEMENT_DISMISSAL_KEY = 'plexDonateAnnouncementDismissed';
      let dismissedAnnouncementFingerprint = null;

      try {
        dismissedAnnouncementFingerprint =
          window.localStorage.getItem(ANNOUNCEMENT_DISMISSAL_KEY) || null;
      } catch (err) {
        dismissedAnnouncementFingerprint = null;
      }

      function normalizeSessionToken(token) {
        if (typeof token !== 'string') {
          return null;
        }
        const trimmed = token.trim();
        return trimmed ? trimmed : null;
      }

      function applySessionTokenToUrl(token) {
        try {
          const url = new URL(window.location.href);
          if (token) {
            url.searchParams.set(SESSION_TOKEN_QUERY_PARAM, token);
          } else {
            url.searchParams.delete(SESSION_TOKEN_QUERY_PARAM);
          }
          const nextUrl = `${url.pathname}${url.search}${url.hash}`;
          window.history.replaceState({}, '', nextUrl);
        } catch (err) {
          // Ignore URL manipulation errors.
        }
      }

      function setSessionToken(token) {
        const normalized = normalizeSessionToken(token);
        if (normalized === sessionToken) {
          return;
        }
        sessionToken = normalized;
        applySessionTokenToUrl(sessionToken);
      }

      (function initializeSessionTokenFromUrl() {
        try {
          const url = new URL(window.location.href);
          const existing = url.searchParams.get(SESSION_TOKEN_QUERY_PARAM);
          if (existing) {
            setSessionToken(existing);
          }
        } catch (err) {
          sessionToken = null;
        }
      })();

      function extractVerificationTokenFromUrl() {
        try {
          const url = new URL(window.location.href);
          const tokenValue = url.searchParams.get(VERIFICATION_TOKEN_QUERY_PARAM);
          if (!tokenValue) {
            return null;
          }
          url.searchParams.delete(VERIFICATION_TOKEN_QUERY_PARAM);
          if (/\/verify\/?$/i.test(url.pathname)) {
            const withoutSegment = url.pathname.replace(/\/verify\/?$/i, '/');
            if (withoutSegment.length > 1 && withoutSegment.endsWith('/')) {
              url.pathname = withoutSegment.slice(0, -1);
            } else {
              url.pathname = withoutSegment || '/';
            }
          }
          const nextUrl = `${url.pathname}${url.search}${url.hash}`;
          window.history.replaceState({}, '', nextUrl);
          return tokenValue;
        } catch (err) {
          return null;
        }
      }

      initialVerificationToken = extractVerificationTokenFromUrl();

      function withSessionToken(path) {
        if (!sessionToken) {
          return path;
        }
        try {
          const url = new URL(path, window.location.origin);
          url.searchParams.set(SESSION_TOKEN_QUERY_PARAM, sessionToken);
          return url.toString();
        } catch (err) {
          return path;
        }
      }

      function updateSessionTokenFromResponse(data) {
        if (!data || typeof data !== 'object') {
          return;
        }
        if (Object.prototype.hasOwnProperty.call(data, 'sessionToken')) {
          setSessionToken(data.sessionToken);
        }
      }

      function normalizeAnnouncementPayload(payload) {
        if (!payload || typeof payload !== 'object') {
          return null;
        }
        const toneRaw = typeof payload.tone === 'string'
          ? payload.tone.trim().toLowerCase()
          : '';
        const tone = Object.prototype.hasOwnProperty.call(
          ANNOUNCEMENT_TONE_LABELS,
          toneRaw
        )
          ? toneRaw
          : 'info';
        const title = typeof payload.title === 'string' ? payload.title.trim() : '';
        const body = typeof payload.body === 'string' ? payload.body.trim() : '';
        const dismissible = Boolean(payload.dismissible);
        const enabled = Boolean(payload.enabled);
        let cta = null;
        if (payload.cta && typeof payload.cta === 'object') {
          const label =
            typeof payload.cta.label === 'string' ? payload.cta.label.trim() : '';
          const url = typeof payload.cta.url === 'string' ? payload.cta.url.trim() : '';
          const openInNewTab = Boolean(payload.cta.openInNewTab);
          if (label && url) {
            cta = { label, url, openInNewTab };
          }
        }
        return { enabled, title, body, tone, dismissible, cta };
      }

      function buildAnnouncementFingerprint(announcement) {
        if (!announcement) {
          return '';
        }
        return JSON.stringify({
          tone: announcement.tone,
          title: announcement.title,
          body: announcement.body,
          dismissible: announcement.dismissible,
          ctaLabel: announcement.cta ? announcement.cta.label : '',
          ctaUrl: announcement.cta ? announcement.cta.url : '',
        });
      }

      function isAnnouncementDismissed(announcement) {
        if (!announcement || !announcement.dismissible) {
          return false;
        }
        const fingerprint = buildAnnouncementFingerprint(announcement);
        return fingerprint && fingerprint === dismissedAnnouncementFingerprint;
      }

      function rememberAnnouncementDismissal(announcement) {
        if (!announcement || !announcement.dismissible) {
          return;
        }
        const fingerprint = buildAnnouncementFingerprint(announcement);
        if (!fingerprint) {
          return;
        }
        dismissedAnnouncementFingerprint = fingerprint;
        try {
          window.localStorage.setItem(ANNOUNCEMENT_DISMISSAL_KEY, fingerprint);
        } catch (err) {
          // ignore storage errors
        }
      }

      function resetAnnouncementCta() {
        if (!announcementCta) {
          return;
        }
        announcementCta.classList.add('hidden');
        announcementCta.textContent = '';
        announcementCta.removeAttribute('href');
        announcementCta.removeAttribute('target');
        announcementCta.removeAttribute('rel');
      }

      function renderAnnouncementBanner(payload) {
        if (!announcementBanner) {
          state.announcement = null;
          return;
        }

        const normalized = normalizeAnnouncementPayload(payload);
        state.announcement = normalized;

        if (
          !normalized ||
          !normalized.enabled ||
          (!normalized.title && !normalized.body) ||
          isAnnouncementDismissed(normalized)
        ) {
          announcementBanner.classList.add('hidden');
          announcementBanner.dataset.tone = 'info';
          if (announcementTitle) {
            announcementTitle.textContent = '';
          }
          if (announcementBody) {
            announcementBody.textContent = '';
            announcementBody.classList.add('hidden');
          }
          resetAnnouncementCta();
          if (announcementDismissButton) {
            announcementDismissButton.classList.add('hidden');
            announcementDismissButton.setAttribute('aria-hidden', 'true');
          }
          return;
        }

        announcementBanner.classList.remove('hidden');
        announcementBanner.dataset.tone = normalized.tone;

        if (announcementChip) {
          announcementChip.textContent =
            ANNOUNCEMENT_TONE_LABELS[normalized.tone] || 'Information';
        }

        if (announcementTitle) {
          announcementTitle.textContent = normalized.title || 'Notice';
        }

        if (announcementBody) {
          if (normalized.body) {
            announcementBody.textContent = normalized.body;
            announcementBody.classList.remove('hidden');
          } else {
            announcementBody.textContent = '';
            announcementBody.classList.add('hidden');
          }
        }

        if (normalized.cta && announcementCta) {
          announcementCta.classList.remove('hidden');
          announcementCta.textContent = normalized.cta.label;
          announcementCta.href = normalized.cta.url;
          if (normalized.cta.openInNewTab) {
            announcementCta.target = '_blank';
            announcementCta.rel = 'noopener';
          } else {
            announcementCta.removeAttribute('target');
            announcementCta.removeAttribute('rel');
          }
        } else {
          resetAnnouncementCta();
        }

        if (announcementDismissButton) {
          if (normalized.dismissible) {
            announcementDismissButton.classList.remove('hidden');
            announcementDismissButton.removeAttribute('aria-hidden');
          } else {
            announcementDismissButton.classList.add('hidden');
            announcementDismissButton.setAttribute('aria-hidden', 'true');
          }
        }
      }

      function renderOverseerrIntegration(integrations) {
        if (!overseerrSection) {
          return;
        }

        const payload =
          integrations && typeof integrations === 'object'
            ? integrations.overseerr || null
            : null;
        const rawUrl =
          payload && payload.url ? String(payload.url).trim() : '';

        if (rawUrl) {
          overseerrSection.classList.remove('hidden');
          if (overseerrLink) {
            overseerrLink.href = rawUrl;
            overseerrLink.removeAttribute('aria-disabled');
            overseerrLink.target = '_blank';
            overseerrLink.rel = 'noopener noreferrer';
          }
          return;
        }

        overseerrSection.classList.add('hidden');
        if (overseerrLink) {
          overseerrLink.href = '#';
          overseerrLink.setAttribute('aria-disabled', 'true');
          overseerrLink.removeAttribute('target');
          overseerrLink.removeAttribute('rel');
        }
      }

      if (announcementDismissButton) {
        announcementDismissButton.addEventListener('click', () => {
          if (!state.announcement || !state.announcement.dismissible) {
            return;
          }
          rememberAnnouncementDismissal(state.announcement);
          renderAnnouncementBanner(null);
        });
      }

      function buildSessionRequest(path, options = {}) {
        const requestUrl = withSessionToken(path);
        const requestOptions = { ...options };
        requestOptions.headers = options && options.headers
          ? { ...options.headers }
          : {};
        if (sessionToken) {
          requestOptions.headers['X-Session-Token'] = sessionToken;
        }
        return { requestUrl, requestOptions };
      }

      async function sessionFetch(path, options = {}) {
        const { requestUrl, requestOptions } = buildSessionRequest(path, options);
        return fetch(requestUrl, requestOptions);
      }

      async function submitVerificationToken(token) {
        if (!token || verificationInFlight) {
          return;
        }
        verificationInFlight = true;
        try {
          showLoading();
          const response = await fetch('/api/customer/verify', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token }),
          });
          let payload = {};
          try {
            payload = await response.json();
          } catch (err) {
            payload = {};
          }
          updateSessionTokenFromResponse(payload);
          if (!response.ok) {
            const errorMessage =
              (payload && payload.error) ||
              'Failed to verify email. Try again shortly.';
            throw new Error(errorMessage);
          }
          renderDashboard(payload);
          if (memberStatusMessage) {
            setStatusText(
              memberStatusMessage,
              'Email verified successfully! Welcome back to the dashboard.',
              'success'
            );
            memberStatusMessage.classList.add('small');
          }
        } catch (err) {
          const message = err && err.message
            ? err.message
            : 'Failed to verify email. Try again shortly.';
          if (state.data && state.data.authenticated) {
            if (memberStatusMessage) {
              setStatusText(memberStatusMessage, message, 'error');
              memberStatusMessage.classList.add('small');
            }
          } else {
            renderDashboard({ authenticated: false });
            setStatusText(loginStatus, message, 'error');
          }
          fetchSession({ silent: true });
        } finally {
          verificationInFlight = false;
          initialVerificationToken = null;
        }
      }

      const profileForm = document.getElementById('profile-form');
      const profileEmail = document.getElementById('profile-email');
      const profileName = document.getElementById('profile-name');
      const profileSubscription = document.getElementById('profile-subscription');
      const profileStatus = document.getElementById('profile-status');
      const profileSave = document.getElementById('profile-save');
      const passwordForm = document.getElementById('password-form');
      const passwordCurrentRow = document.getElementById('password-current-row');
      const passwordCurrent = document.getElementById('password-current');
      const passwordNew = document.getElementById('password-new');
      const passwordConfirm = document.getElementById('password-confirm');
      const passwordStatus = document.getElementById('password-status');
      const passwordSave = document.getElementById('password-save');
      const passwordGuidance = document.getElementById('password-guidance');
      const passwordPanel = document.getElementById('password-panel');

      const inviteForm = document.getElementById('invite-form');
      const inviteEmail = document.getElementById('invite-email');
      const inviteNote = document.getElementById('invite-note');
      const inviteStatus = document.getElementById('invite-status');
      const inviteSubmit = document.getElementById('invite-submit');
      const inviteReady = document.getElementById('invite-ready');
      const inviteLinkEl = document.getElementById('invite-link');
      const inviteEmailDisplay = document.getElementById('invite-email-display');
      const inviteCreated = document.getElementById('invite-created');
      const inviteDescription = document.getElementById('invite-description');

      function showLoading() {
        loadingPanel.classList.remove('hidden');
        errorPanel.classList.add('hidden');
        app.classList.add('hidden');
      }

      function showError(message) {
        loadingPanel.classList.add('hidden');
        errorPanel.textContent = message || 'Something went wrong.';
        errorPanel.classList.remove('hidden');
        app.classList.add('hidden');
      }

      function showApp() {
        loadingPanel.classList.add('hidden');
        errorPanel.classList.add('hidden');
        app.classList.remove('hidden');
      }

      function formatPrice(amount, currency) {
        if (!Number.isFinite(amount) || amount <= 0) {
          return '';
        }
        try {
          return new Intl.NumberFormat(undefined, {
            style: 'currency',
            currency: currency || 'USD',
            minimumFractionDigits: 2,
          }).format(amount);
        } catch (err) {
          return `${amount.toFixed(2)} ${currency || ''}`.trim();
        }
      }

      function formatDate(value) {
        if (!value) {
          return '';
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return value;
        }
        return date.toLocaleString();
      }

      function parseDate(value) {
        if (!value) {
          return null;
        }
        if (value instanceof Date) {
          return Number.isNaN(value.getTime()) ? null : value;
        }
        const parsed = new Date(value);
        return Number.isNaN(parsed.getTime()) ? null : parsed;
      }

      function formatDateTime(value) {
        const date = parseDate(value);
        if (!date) {
          return '';
        }
        try {
          return new Intl.DateTimeFormat(undefined, {
            dateStyle: 'medium',
            timeStyle: 'short',
          }).format(date);
        } catch (err) {
          return date.toLocaleString();
        }
      }

      function getPlexCountdownLabel(expiresAt) {
        const date = parseDate(expiresAt);
        if (!date) {
          return '';
        }
        const diff = date.getTime() - Date.now();
        if (diff <= 0) {
          return '';
        }
        const minutes = Math.max(0, Math.floor(diff / 60000));
        const seconds = Math.max(0, Math.floor((diff % 60000) / 1000));
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
      }

      function clearInviteCooldownTimer() {
        if (!inviteCooldownTimer) {
          return;
        }
        if (inviteCooldownTimerType === 'interval') {
          window.clearInterval(inviteCooldownTimer);
        } else {
          window.clearTimeout(inviteCooldownTimer);
        }
        inviteCooldownTimer = null;
        inviteCooldownTimerType = null;
      }

      function scheduleInviteCooldownRefresh(nextAvailableAt) {
        clearInviteCooldownTimer();
        const nextDate = parseDate(nextAvailableAt);
        state.nextInviteAvailableAt = nextDate
          ? nextDate.toISOString()
          : null;
        if (!nextDate) {
          return;
        }
        const delay = nextDate.getTime() - Date.now();
        if (delay <= 0) {
          fetchSession({ silent: true });
          return;
        }
        const MAX_TIMEOUT = 2_147_483_647;
        if (delay > MAX_TIMEOUT) {
          inviteCooldownTimer = window.setInterval(() => {
            if (Date.now() >= nextDate.getTime()) {
              clearInviteCooldownTimer();
              fetchSession({ silent: true });
            }
          }, 60 * 60 * 1000);
          inviteCooldownTimerType = 'interval';
        } else {
          inviteCooldownTimer = window.setTimeout(() => {
            clearInviteCooldownTimer();
            fetchSession({ silent: true });
          }, delay);
          inviteCooldownTimerType = 'timeout';
        }
      }

      function setStatusText(el, message, statusClass) {
        if (!el) return;
        el.textContent = message || '';
        el.className = 'status-text';
        if (statusClass) {
          el.classList.add(statusClass);
        }
      }

      function formatSupportTimestamp(value) {
        if (!value) {
          return '';
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return '';
        }
        return date.toLocaleString();
      }

      function getSupportThreadLocal(id) {
        const threads = Array.isArray(state.support.threads)
          ? state.support.threads
          : [];
        return threads.find(
          (thread) => thread && thread.request && thread.request.id === id
        );
      }

      function renderSupportThreadDetail() {
        if (!supportThreadDetail || !supportThreadSubject || !supportMessages) {
          return;
        }
        const thread = getSupportThreadLocal(state.support.activeThreadId);
        if (!thread) {
          supportThreadDetail.classList.add('hidden');
          return;
        }
        supportThreadDetail.classList.remove('hidden');
        supportThreadSubject.textContent =
          thread.request.subject || `Request #${thread.request.id}`;
        const isResolved = Boolean(thread.request.resolved);
        supportThreadStatus.textContent = isResolved ? 'Resolved' : 'Open';
        supportThreadStatus.classList.toggle('support-status-open', !isResolved);
        supportThreadStatus.classList.toggle('support-status-resolved', isResolved);
        supportMessages.innerHTML = '';
        const messages = Array.isArray(thread.messages) ? thread.messages : [];
        if (messages.length === 0) {
          const emptyMessage = document.createElement('p');
          emptyMessage.className = 'support-empty';
          emptyMessage.textContent = 'No messages yet.';
          supportMessages.appendChild(emptyMessage);
        } else {
          messages.forEach((message) => {
            const messageEl = document.createElement('div');
            messageEl.className = 'support-message';
            messageEl.dataset.author = message.authorRole || 'donor';

            const authorEl = document.createElement('div');
            authorEl.className = 'support-message-author';
            authorEl.textContent =
              message.authorName ||
              (message.authorRole === 'admin' ? 'Admin' : 'You');

            const metaEl = document.createElement('div');
            metaEl.className = 'support-message-meta';
            metaEl.textContent = formatSupportTimestamp(message.createdAt);

            const bodyEl = document.createElement('div');
            bodyEl.textContent = message.body || '';

            messageEl.append(authorEl, metaEl, bodyEl);
            supportMessages.appendChild(messageEl);
          });
          supportMessages.scrollTop = supportMessages.scrollHeight;
        }

        if (supportReplyMessage) {
          supportReplyMessage.value = '';
        }
        if (supportReplyStatus) {
          setStatusText(supportReplyStatus, '');
        }
      }

      function renderSupportThreads() {
        if (!supportThreadList || !supportThreads) {
          return;
        }
        const threads = Array.isArray(state.support.threads)
          ? state.support.threads
          : [];
        supportThreadList.innerHTML = '';
        if (threads.length === 0) {
          if (supportEmpty) {
            supportEmpty.classList.remove('hidden');
          }
          supportThreadDetail && supportThreadDetail.classList.add('hidden');
          return;
        }

        if (supportEmpty) {
          supportEmpty.classList.add('hidden');
        }

        if (!threads.some((thread) => thread.request.id === state.support.activeThreadId)) {
          state.support.activeThreadId = threads[0].request.id;
        }

        threads.forEach((thread) => {
          if (!thread || !thread.request) {
            return;
          }
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'support-thread-button';
          const isActive = thread.request.id === state.support.activeThreadId;
          button.setAttribute('aria-current', isActive ? 'true' : 'false');

          const titleEl = document.createElement('h3');
          titleEl.textContent = thread.request.subject || `Request #${thread.request.id}`;

          const statusEl = document.createElement('span');
          const resolved = Boolean(thread.request.resolved);
          statusEl.className = `support-status-pill ${resolved ? 'support-status-resolved' : 'support-status-open'}`;
          statusEl.textContent = resolved ? 'Resolved' : 'Open';

          button.append(titleEl, statusEl);
          button.addEventListener('click', () => {
            state.support.activeThreadId = thread.request.id;
            renderSupportThreads();
          });

          supportThreadList.appendChild(button);
        });

        renderSupportThreadDetail();
      }

      async function loadSupportThreads(options = {}) {
        while (supportThreadsRequest) {
          try {
            await supportThreadsRequest;
          } catch (err) {
            // Previous invocation already handled the error display.
          }
        }

        const request = (async () => {
          supportLoading = true;
          try {
            const response = await sessionFetch('/api/customer/support');
            const payload = await response.json();
            updateSessionTokenFromResponse(payload);
            if (!response.ok) {
              throw new Error(
                payload && payload.error
                  ? payload.error
                  : 'Failed to load support requests'
              );
            }
            const threads = Array.isArray(payload.threads) ? payload.threads : [];
            state.support.threads = threads;
            if (threads.length === 0) {
              state.support.activeThreadId = null;
            }
            renderSupportThreads();
            return payload;
          } catch (err) {
            if (!options.silent && supportStatus) {
              setStatusText(
                supportStatus,
                err.message || 'Failed to load support requests.',
                'error'
              );
            }
            return null;
          } finally {
            supportLoading = false;
          }
        })();

        supportThreadsRequest = request.finally(() => {
          supportThreadsRequest = null;
        });

        return supportThreadsRequest;
      }

      async function setSupportPanelOpen(open) {
        if (!supportContainer || !supportToggle) {
          return;
        }
        supportPanelOpen = Boolean(open);
        if (supportPanelOpen) {
          supportContainer.classList.remove('hidden');
          supportToggle.textContent = 'Hide support';
          await loadSupportThreads({ silent: true });
        } else {
          supportContainer.classList.add('hidden');
          supportToggle.textContent = 'Contact support';
        }
      }

      function clearPlexLinkPollTimer() {
        if (!plexLinkPollTimer) {
          return;
        }
        window.clearTimeout(plexLinkPollTimer);
        plexLinkPollTimer = null;
      }

      function schedulePlexLinkStatusPoll(intervalMs) {
        if (!state.pendingPlexLink) {
          clearPlexLinkPollTimer();
          return;
        }
        const normalized = Number(intervalMs ?? state.pendingPlexLink.pollIntervalMs);
        const delay = Number.isFinite(normalized) && normalized > 0 ? normalized : 5000;
        clearPlexLinkPollTimer();
        plexLinkPollTimer = window.setTimeout(() => {
          plexLinkPollTimer = null;
          pollPlexLinkStatus();
        }, delay);
      }

      function clearPlexLinkCountdownTimer({ resetText = true } = {}) {
        if (plexLinkCountdownTimer) {
          window.clearInterval(plexLinkCountdownTimer);
          plexLinkCountdownTimer = null;
        }
        plexLinkCountdownExpiryMs = null;
        if (resetText && plexLinkPinExpiry) {
          plexLinkPinExpiry.textContent = '';
        }
      }

      function updatePlexLinkCountdownDisplay() {
        if (!plexLinkPinExpiry || !Number.isFinite(plexLinkCountdownExpiryMs)) {
          if (plexLinkPinExpiry) {
            plexLinkPinExpiry.textContent = '';
          }
          return '';
        }
        const diff = plexLinkCountdownExpiryMs - Date.now();
        if (diff <= 0) {
          plexLinkPinExpiry.textContent = 'PIN expired';
          return '';
        }
        const minutes = Math.max(0, Math.floor(diff / 60000));
        const seconds = Math.max(0, Math.floor((diff % 60000) / 1000));
        const formatted = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        plexLinkPinExpiry.textContent = `Expires in ${formatted}`;
        return formatted;
      }

      function startPlexLinkCountdown(expiresAt) {
        const date = parseDate(expiresAt);
        if (!date) {
          clearPlexLinkCountdownTimer();
          return '';
        }
        const targetMs = date.getTime();
        if (plexLinkCountdownTimer && plexLinkCountdownExpiryMs === targetMs) {
          return updatePlexLinkCountdownDisplay();
        }
        clearPlexLinkCountdownTimer();
        plexLinkCountdownExpiryMs = targetMs;
        const initial = updatePlexLinkCountdownDisplay();
        if (!initial) {
          return '';
        }
        plexLinkCountdownTimer = window.setInterval(() => {
          const next = updatePlexLinkCountdownDisplay();
          if (!next) {
            clearPlexLinkCountdownTimer({ resetText: false });
          }
        }, 1000);
        return initial;
      }

      function closePlexAuthWindow() {
        if (plexLinkAuthWindow && !plexLinkAuthWindow.closed) {
          try {
            plexLinkAuthWindow.close();
          } catch (err) {
            // Ignore window close errors.
          }
        }
        plexLinkAuthWindow = null;
      }

      function setPlexLinkStatus(message, tone, { sticky = false, force = false } = {}) {
        if (!force && plexLinkStatusSticky && !sticky) {
          return;
        }
        plexLinkStatusSticky = sticky;
        if (!plexLinkStatus) {
          return;
        }
        setStatusText(plexLinkStatus, message, tone || null);
        plexLinkStatus.classList.add('small');
      }

      function clearPlexLinkStatus({ force = false } = {}) {
        if (!force && plexLinkStatusSticky) {
          return;
        }
        plexLinkStatusSticky = false;
        if (!plexLinkStatus) {
          return;
        }
        setStatusText(plexLinkStatus, '', null);
        plexLinkStatus.classList.add('small');
      }

      async function pollPlexLinkStatus() {
        if (!state.pendingPlexLink) {
          clearPlexLinkPollTimer();
          return;
        }
        let response;
        try {
          response = await sessionFetch('/api/customer/plex/link/status');
        } catch (err) {
          setPlexLinkStatus('Unable to reach Plex right now. Retrying…', 'error', {
            force: true,
          });
          schedulePlexLinkStatusPoll(state.pendingPlexLink.pollIntervalMs);
          return;
        }
        let payload = {};
        try {
          payload = await response.json();
        } catch (err) {
          payload = {};
        }
        updateSessionTokenFromResponse(payload);
        if (!response.ok) {
          const payloadData = payload && payload.payload ? payload.payload : null;
          if (payloadData) {
            renderDashboard(payloadData);
          } else {
            applyPlexLinkState(null, null);
          }
          const plexErrorMessage = payload && payload.error
            ? `${payload.error} Try starting the link again.`
            : 'Failed to verify Plex authentication. Try starting the link again.';
          setPlexLinkStatus(plexErrorMessage, 'error', { sticky: true, force: true });
          clearPlexLinkPollTimer();
          clearPlexLinkCountdownTimer({ resetText: false });
          closePlexAuthWindow();
          return;
        }
        renderDashboard(payload);
      }

      function applyPlexLinkState(donor, plexLink) {
        const plexLinked = Boolean(donor && donor.plexLinked);
        const pending = plexLink && plexLink.pending ? plexLink : null;

        if (pending) {
          state.pendingPlexLink = {
            code: pending.code || '',
            authUrl: pending.authUrl || '',
            expiresAt: pending.expiresAt || null,
            pollIntervalMs: Number(pending.pollIntervalMs) || null,
          };
        } else {
          state.pendingPlexLink = null;
        }

        if (plexLinkButton) {
          if (plexLinked || pending) {
            plexLinkButton.classList.add('hidden');
            plexLinkButton.disabled = true;
          } else {
            plexLinkButton.classList.remove('hidden');
            plexLinkButton.disabled = false;
          }
        }

        if (pending) {
          if (plexLinkPin) {
            plexLinkPin.classList.remove('hidden');
          }
          if (plexLinkPinCode) {
            plexLinkPinCode.textContent = state.pendingPlexLink.code || '----';
          }
          const countdown = startPlexLinkCountdown(state.pendingPlexLink.expiresAt);
          const baseMessage =
            'Waiting for Plex to confirm your account. Complete the Plex prompt in the new tab.';
          const message = countdown
            ? `${baseMessage} PIN expires in ${countdown}.`
            : baseMessage;
          setPlexLinkStatus(message, 'info', { force: true });
          schedulePlexLinkStatusPoll(state.pendingPlexLink.pollIntervalMs);
        } else {
          clearPlexLinkCountdownTimer();
          clearPlexLinkPollTimer();
          if (plexLinkPin) {
            plexLinkPin.classList.add('hidden');
          }
          if (plexLinkPinCode) {
            plexLinkPinCode.textContent = '----';
          }
          if (plexLinkPinExpiry) {
            plexLinkPinExpiry.textContent = '';
          }
          if (plexLinked) {
            setPlexLinkStatus('Plex account linked successfully.', 'success', {
              force: true,
            });
          } else {
            setPlexLinkStatus(
              'Link your Plex account so we can enable PayPal checkout and invites.',
              'info'
            );
          }
          closePlexAuthWindow();
        }
      }

      function updateMembershipStatusMessage(
        donor,
        {
          showSubscriptionCta,
          nextInviteMessage = '',
          cooldownActive = false,
          refreshError = '',
          plexLinked = false,
          emailVerified = true,
        } = {}
      ) {
        if (!memberStatusMessage) {
          return;
        }

        const normalizedRefreshError =
          typeof refreshError === 'string' ? refreshError.trim() : '';
        if (normalizedRefreshError) {
          setStatusText(memberStatusMessage, normalizedRefreshError, 'error');
          memberStatusMessage.classList.add('small');
          return;
        }

        if (donor && !emailVerified) {
          setStatusText(
            memberStatusMessage,
            'Check your inbox for the verification email to unlock your dashboard.',
            'error'
          );
          memberStatusMessage.classList.add('small');
          return;
        }

        const normalizedStatus = (donor && donor.status
          ? donor.status
          : 'pending'
        ).toLowerCase();
        const lastPayment = donor && donor.lastPaymentAt ? formatDate(donor.lastPaymentAt) : '';

        let tone = 'info';
        let message = '';

        switch (normalizedStatus) {
          case 'active':
            tone = 'success';
            if (nextInviteMessage && cooldownActive) {
              message = `${nextInviteMessage} We'll refresh this dashboard automatically when your next referral unlocks so you can share it or regenerate your own link if you've lost access.`;
            } else if (nextInviteMessage) {
              message = `Your subscription is active. ${nextInviteMessage} Share a referral invite below when it unlocks—or regenerate your own link if you've lost access.`;
            } else if (lastPayment) {
              message = `Your subscription is active. Last payment recorded ${lastPayment}. Share a referral invite below when you're ready, and only regenerate your own link if you've lost access.`;
            } else {
              message = 'Your subscription is active. Share referral invites below to welcome someone new, and only regenerate your own link if you have lost access.';
            }
            break;
          case 'pending':
            tone = 'info';
            if (!donor || !donor.subscriptionId) {
              if (!plexLinked) {
                message =
                  'Link your Plex account above to unlock the PayPal checkout or paste your subscription ID once you have it.';
              } else if (showSubscriptionCta) {
                message =
                  'Start your PayPal subscription above or paste an existing subscription ID below to activate your membership.';
              } else {
                message =
                  'Already subscribed? Add your PayPal subscription ID below so we can link it to your account.';
              }
            } else {
              message =
                'We are waiting for PayPal to confirm your first payment. Check PayPal for any required steps.';
            }
            break;
          case 'cancelled':
            tone = 'error';
            message =
              'Your PayPal subscription was canceled. Start a new subscription to regain access.';
            break;
          case 'suspended':
            tone = 'error';
            message =
              'Your PayPal subscription is suspended. Update your billing details in PayPal to resume access.';
            break;
          case 'expired':
            tone = 'error';
            message =
              'Your PayPal subscription expired. Start a new subscription to continue access.';
            break;
          case 'past_due':
            tone = 'error';
            message =
              'Your subscription payment is past due. Update your PayPal billing information to avoid interruptions.';
            break;
          default:
            tone = 'info';
            message =
              'Your subscription status is being updated. Contact the server admin if this looks wrong.';
            break;
        }

        setStatusText(memberStatusMessage, message, tone);
        memberStatusMessage.classList.add('small');
      }

      function renderInvite(
        invite,
        limitReached,
        nextInviteAvailableAt,
        { emailVerified = true } = {}
      ) {
        const limitHit = Boolean(limitReached);
        const nextAvailableDate = parseDate(nextInviteAvailableAt);
        const cooldownActive =
          limitHit && nextAvailableDate && nextAvailableDate.getTime() > Date.now();
        const nextInviteMessage = cooldownActive
          ? `Next referral invite available on ${formatDateTime(nextAvailableDate)}.`
          : '';

        if (inviteStatus) {
          if (!emailVerified) {
            setStatusText(
              inviteStatus,
              'Verify your email to unlock referral invites.',
              'info'
            );
          } else {
            setStatusText(inviteStatus, '');
          }
        }

        if (inviteForm) {
          if (limitHit) {
            inviteForm.classList.add('hidden');
          } else {
            inviteForm.classList.remove('hidden');
          }
        }

          if (!invite || !invite.inviteUrl) {
            inviteReady.classList.add('hidden');
            inviteLinkEl.removeAttribute('href');
            inviteLinkEl.textContent = '';
            inviteEmailDisplay.textContent = '';
            inviteCreated.textContent = '';
          if (cooldownActive && nextInviteMessage) {
            inviteDescription.textContent =
              `${nextInviteMessage} We'll refresh this dashboard automatically when you're eligible to send another referral invite.`;
          } else {
            inviteDescription.textContent = limitHit
              ? 'This month’s referral invite has already been used. Contact the server admin if you lost access and need the link restored.'
              : 'Active subscribers can send one referral invite each month. Use the form below when you are ready to share it—and only regenerate your own link if you have lost access.';
          }
          if (inviteSubmit) {
            if (cooldownActive) {
              inviteSubmit.textContent = 'Referral invite cooling down…';
            } else {
              inviteSubmit.textContent = limitHit
                ? 'Referral invite already sent'
                : 'Send referral invite';
            }
            inviteSubmit.disabled = limitHit;
          }
          return;
        }

          inviteReady.classList.remove('hidden');
          inviteLinkEl.href = invite.inviteUrl;
          inviteLinkEl.textContent = invite.inviteUrl;
        inviteEmailDisplay.textContent = invite.recipientEmail
          ? `Delivering to ${invite.recipientEmail}`
          : '';
        inviteCreated.textContent = invite.createdAt
          ? `Created ${formatDate(invite.createdAt)}`
          : '';
        if (cooldownActive && nextInviteMessage) {
          inviteDescription.textContent =
            `${nextInviteMessage} We'll refresh this dashboard automatically when the referral cooldown ends.`;
        } else {
          inviteDescription.textContent = limitHit
            ? 'Referral invite ready! Reach out to the server admin if you lost access and need the link refreshed.'
            : 'Referral invite ready! Share the link below with your recipient—only follow it yourself if you’re restoring access.';
        }
        if (inviteSubmit) {
          if (cooldownActive) {
            inviteSubmit.textContent = 'Referral invite cooling down…';
          } else {
            inviteSubmit.textContent = limitHit
              ? 'Referral invite already sent'
              : 'Send another referral invite';
          }
          inviteSubmit.disabled = limitHit;
        }
      }

      function setStepState(stepEl, state) {
        if (!stepEl) {
          return;
        }
        const allowed = new Set(['complete', 'current', 'upcoming']);
        const normalized = allowed.has(state) ? state : 'upcoming';
        stepEl.dataset.state = normalized;
        const numberEl = stepEl.querySelector('.step-number');
        if (numberEl && numberEl.dataset && numberEl.dataset.stepNumber) {
          if (normalized === 'complete') {
            numberEl.textContent = '✓';
          } else {
            numberEl.textContent = numberEl.dataset.stepNumber;
          }
        }
      }

      function updateOnboarding(
        data,
        {
          showSubscriptionCta,
          inviteCooldownActive = false,
          nextInviteMessage = '',
          emailVerified = true,
        } = {}
      ) {
        if (!onboardingPanel) {
          return;
        }

        const donor = data && data.donor ? data.donor : null;
        if (donor && !emailVerified) {
          onboardingPanel.classList.remove('hidden');
          if (stepPlex) {
            setStepState(stepPlex, 'upcoming');
          }
          if (stepSubscription) {
            setStepState(stepSubscription, 'upcoming');
          }
          if (stepInvite) {
            setStepState(stepInvite, 'upcoming');
          }
          const verificationNote =
            'Verify your email from the link we sent to unlock the rest of your setup steps.';
          if (stepPlexNote) {
            stepPlexNote.textContent = verificationNote;
          }
          if (stepSubscriptionNote) {
            stepSubscriptionNote.textContent = verificationNote;
          }
          if (stepInviteNote) {
            stepInviteNote.textContent = verificationNote;
          }
          return;
        }

        const normalizedStatus = donor && donor.status
          ? donor.status.toLowerCase()
          : 'pending';
        const subscriptionComplete = normalizedStatus === 'active';
        const subscriptionStarted = Boolean(donor && donor.subscriptionId);
        const plexLinked = Boolean(donor && donor.plexLinked);
        const plexLinkPending = Boolean(
          data &&
            data.plexLink &&
            typeof data.plexLink.pending === 'boolean' &&
            data.plexLink.pending
        );
          const inviteReadyState = Boolean(
            data && data.invite && data.invite.inviteUrl
          );
        const inviteLimitReached = Boolean(data && data.inviteLimitReached);
        const allComplete = plexLinked && subscriptionComplete && inviteReadyState;

        if (allComplete) {
          onboardingPanel.classList.add('hidden');
          return;
        }

        onboardingPanel.classList.remove('hidden');

        const steps = [
          { el: stepPlex, complete: plexLinked },
          { el: stepSubscription, complete: subscriptionComplete },
          { el: stepInvite, complete: inviteReadyState },
        ];

        let currentAssigned = false;
        for (const step of steps) {
          if (!step.el) {
            continue;
          }
          if (step.complete) {
            setStepState(step.el, 'complete');
          } else if (!currentAssigned) {
            setStepState(step.el, 'current');
            currentAssigned = true;
          } else {
            setStepState(step.el, 'upcoming');
          }
        }

        if (stepPlexNote) {
          if (plexLinked) {
            if (subscriptionComplete) {
              stepPlexNote.textContent =
                'Plex account verified—time to send your referral invite!';
            } else {
              stepPlexNote.textContent =
                'Plex account verified—head to the next step to start your membership.';
            }
          } else if (plexLinkPending) {
            const countdownLabel =
              data && data.plexLink
                ? getPlexCountdownLabel(data.plexLink.expiresAt)
                : '';
            if (countdownLabel) {
              stepPlexNote.textContent =
                `Plex authentication in progress—finish the prompt before it expires in ${countdownLabel}. We'll refresh this card automatically.`;
            } else {
              stepPlexNote.textContent =
                'Follow the Plex prompt you opened to finish authentication. This card updates automatically.';
            }
          } else {
            stepPlexNote.textContent =
              'Use the button below to launch the Plex authentication prompt and link your streaming account. We will update this step as soon as verification completes.';
          }
        }

        if (stepSubscriptionNote) {
          if (!plexLinked) {
            stepSubscriptionNote.textContent =
              'Finish Plex authentication first—we unlock the PayPal checkout and subscription linking right after.';
          } else if (!subscriptionStarted) {
            if (showSubscriptionCta) {
              stepSubscriptionNote.textContent =
                'Use the PayPal button above or paste your subscription ID below to kick off your membership.';
            } else {
              stepSubscriptionNote.textContent =
                'Already supporting the server? Paste your PayPal subscription ID below and we will link it automatically.';
            }
          } else if (!subscriptionComplete) {
            stepSubscriptionNote.textContent =
              'We are waiting for PayPal to confirm your first payment. This usually takes just a moment.';
          } else {
            stepSubscriptionNote.textContent =
              'Subscription active! You are ready for the next step.';
          }
        }

        if (stepInviteNote) {
          if (!plexLinked) {
            stepInviteNote.textContent =
              'Finish Plex authentication and we’ll enable referral invites.';
          } else if (!subscriptionComplete) {
            stepInviteNote.textContent =
              'Referral invites unlock after your subscription is active.';
          } else if (!inviteReadyState) {
            stepInviteNote.textContent =
              'Use the form below to send a referral invite as soon as you are verified. Only regenerate your own link if you have lost access.';
          } else if (inviteLimitReached) {
            if (inviteCooldownActive && nextInviteMessage) {
              stepInviteNote.textContent =
                `${nextInviteMessage} We'll refresh this dashboard automatically when you can send the next referral invite.`;
            } else {
              stepInviteNote.textContent =
                'Your referral invite is ready below. Reach out to the server admin if you lost access and need it refreshed.';
            }
          } else {
            stepInviteNote.textContent =
              'Referral invite ready! Share it with your recipient—only use it yourself if you’re restoring access.';
          }
        }
      }

      function renderDashboard(data) {
        state.data = data;
        showApp();

        const hasAnnouncement =
          data && Object.prototype.hasOwnProperty.call(data, 'announcement');
        const announcementPayload = hasAnnouncement
          ? data.announcement
          : state.announcement;
        renderAnnouncementBanner(announcementPayload);
        renderOverseerrIntegration(data && data.integrations);

        if (!data || !data.authenticated) {
          loginPanel.classList.remove('hidden');
          dashboardPanel.classList.add('hidden');
          loginForm.reset();
          setStatusText(loginStatus, '');
          setStatusText(memberStatusMessage, '');
          clearInviteCooldownTimer();
          clearPlexLinkPollTimer();
          clearPlexLinkCountdownTimer();
          closePlexAuthWindow();
          state.inviteLimitReached = false;
          state.nextInviteAvailableAt = null;
          state.pendingPlexLink = null;
          plexLinkStatusSticky = false;
          clearPlexLinkStatus({ force: true });
          if (plexLinkButton) {
            plexLinkButton.disabled = false;
            plexLinkButton.classList.remove('hidden');
          }
          if (plexLinkPin) {
            plexLinkPin.classList.add('hidden');
          }
          if (plexLinkPinCode) {
            plexLinkPinCode.textContent = '----';
          }
          if (plexLinkPinExpiry) {
            plexLinkPinExpiry.textContent = '';
          }
          if (forgotPasswordHelp) {
            forgotPasswordHelp.classList.add('hidden');
          }
          if (forgotPasswordLink) {
            forgotPasswordLink.textContent = defaultForgotPasswordLinkText;
            forgotPasswordLink.setAttribute('aria-expanded', 'false');
          }
          if (onboardingPanel) {
            onboardingPanel.classList.add('hidden');
          }
          if (passwordForm) {
            passwordForm.reset();
          }
          if (passwordStatus) {
            setStatusText(passwordStatus, '');
          }
          if (passwordSave) {
            passwordSave.disabled = false;
          }
          if (profileSubscription) {
            profileSubscription.value = '';
          }
          return;
        }

        loginPanel.classList.add('hidden');
        dashboardPanel.classList.remove('hidden');

        const donor = data.donor || {};
        const emailVerified = Boolean(donor.emailVerified);
        if (emailVerified) {
          applyPlexLinkState(donor, data.plexLink || null);
        } else {
          clearPlexLinkCountdownTimer();
          clearPlexLinkPollTimer();
          closePlexAuthWindow();
          state.pendingPlexLink = null;
          plexLinkStatusSticky = true;
          if (plexLinkButton) {
            plexLinkButton.disabled = true;
            plexLinkButton.classList.remove('hidden');
          }
          if (plexLinkPin) {
            plexLinkPin.classList.add('hidden');
          }
          if (plexLinkPinCode) {
            plexLinkPinCode.textContent = '----';
          }
          if (plexLinkPinExpiry) {
            plexLinkPinExpiry.textContent = '';
          }
          setPlexLinkStatus(
            'Verify your email address to unlock Plex linking.',
            'info',
            { force: true }
          );
        }
        memberNameEl.textContent = donor.name
          ? `Hi ${donor.name}!`
          : 'Add a display name below so we know how to greet you.';
        memberEmailEl.textContent = donor.email
          ? donor.email
          : 'Set your preferred streaming email under profile settings.';

        const normalizedStatus = (donor.status || 'pending').toLowerCase();
        const plexLinked = Boolean(donor.plexLinked);
        if (memberStatusEl) {
          memberStatusEl.dataset.status = normalizedStatus;
          memberStatusEl.textContent = normalizedStatus || 'pending';
        }

        if (donor.subscriptionId) {
          memberSubscriptionRow.classList.remove('hidden');
          memberSubscriptionId.textContent = donor.subscriptionId;
        } else {
          memberSubscriptionRow.classList.add('hidden');
          memberSubscriptionId.textContent = '';
        }

        if (donor.lastPaymentAt) {
          memberLastPaymentRow.classList.remove('hidden');
          memberLastPayment.textContent = formatDate(donor.lastPaymentAt);
        } else {
          memberLastPaymentRow.classList.add('hidden');
          memberLastPayment.textContent = '';
        }

        const price = formatPrice(
          Number(data.paypal && data.paypal.subscriptionPrice),
          data.paypal && data.paypal.currency
        );
        if (price) {
          memberPlanEl.classList.remove('hidden');
          memberPlanEl.innerHTML = `<span class="label">Monthly support</span><span>${price}</span>`;
        } else {
          memberPlanEl.classList.add('hidden');
          memberPlanEl.innerHTML = '';
        }

        const subscriptionCheckoutEligible = Boolean(
          emailVerified &&
            data.paypal &&
            data.paypal.subscriptionCheckoutAvailable &&
            (!donor.subscriptionId || normalizedStatus !== 'active')
        );
        const showSubscriptionCta = Boolean(
          subscriptionCheckoutEligible && plexLinked
        );

        const limitReached = Boolean(data.inviteLimitReached);
        state.inviteLimitReached = limitReached;
        const nextInviteAvailableAt = data.nextInviteAvailableAt || null;
        const nextInviteDate = parseDate(nextInviteAvailableAt);
        const nextInviteInFuture =
          nextInviteDate && nextInviteDate.getTime() > Date.now();
        const nextInviteMessage = nextInviteInFuture
          ? `Next invite available on ${formatDateTime(nextInviteDate)}.`
          : '';
        const inviteCooldownActive = limitReached && nextInviteInFuture;
        scheduleInviteCooldownRefresh(
          inviteCooldownActive ? nextInviteAvailableAt : null
        );

        updateMembershipStatusMessage(donor, {
          showSubscriptionCta,
          nextInviteMessage,
          cooldownActive: inviteCooldownActive,
          refreshError:
            data.paypal && typeof data.paypal.refreshError === 'string'
              ? data.paypal.refreshError
              : '',
          plexLinked,
          emailVerified,
        });
        updateOnboarding(data, {
          showSubscriptionCta,
          inviteCooldownActive,
          nextInviteMessage,
          emailVerified,
        });

        if (subscriptionButton && subscriptionCta) {
          if (!emailVerified) {
            subscriptionCta.classList.remove('hidden');
            subscriptionButton.classList.remove('hidden');
            subscriptionButton.disabled = true;
            subscriptionButton.dataset.available = 'false';
            subscriptionButton.textContent = defaultSubscriptionButtonLabel;
            setStatusText(
              subscriptionNote,
              'Verify your email to unlock the PayPal checkout.',
              'info'
            );
            subscriptionNote.classList.add('small');
          } else if (showSubscriptionCta) {
            subscriptionCta.classList.remove('hidden');
            subscriptionButton.classList.remove('hidden');
            subscriptionButton.disabled = false;
            subscriptionButton.dataset.available = 'true';
            subscriptionButton.textContent = defaultSubscriptionButtonLabel;
            setStatusText(
              subscriptionNote,
              'Opens PayPal checkout in a new tab.',
              'info'
            );
            subscriptionNote.classList.add('small');
          } else if (subscriptionCheckoutEligible && !plexLinked) {
            subscriptionCta.classList.remove('hidden');
            subscriptionButton.classList.add('hidden');
            subscriptionButton.disabled = true;
            subscriptionButton.dataset.available = 'false';
            subscriptionButton.textContent = defaultSubscriptionButtonLabel;
            setStatusText(
              subscriptionNote,
              'Link your Plex account above and we will unlock the PayPal checkout automatically.',
              'info'
            );
            subscriptionNote.classList.add('small');
          } else {
            subscriptionCta.classList.add('hidden');
            subscriptionButton.classList.remove('hidden');
            subscriptionButton.disabled = true;
            subscriptionButton.dataset.available = 'false';
            subscriptionButton.textContent = defaultSubscriptionButtonLabel;
            setStatusText(subscriptionNote, '', null);
            subscriptionNote.classList.add('small');
          }
        }

        profileEmail.value = donor.email || '';
        profileName.value = donor.name || '';
        if (profileSubscription) {
          profileSubscription.value = donor.subscriptionId || '';
        }
        if (profileEmail) {
          profileEmail.disabled = !emailVerified;
        }
        if (profileName) {
          profileName.disabled = !emailVerified;
        }
        if (profileSubscription) {
          profileSubscription.disabled = !emailVerified;
        }
        if (profileSave) {
          profileSave.disabled = !emailVerified;
        }
        if (passwordForm) {
          passwordForm.reset();
        }
        if (passwordStatus) {
          setStatusText(passwordStatus, '');
        }
        if (passwordGuidance) {
          if (!emailVerified) {
            passwordGuidance.textContent =
              'Verify your email to enable password updates.';
          } else {
            passwordGuidance.textContent = donor.hasPassword
              ? 'Update your dashboard password to keep your account secure.'
              : 'Set a password so you can return to the dashboard anytime.';
          }
        }
        if (passwordCurrentRow) {
          if (donor.hasPassword) {
            passwordCurrentRow.classList.remove('hidden');
          } else {
            passwordCurrentRow.classList.add('hidden');
          }
        }
        if (passwordCurrent) {
          passwordCurrent.disabled = !emailVerified || !donor.hasPassword;
          passwordCurrent.required = Boolean(emailVerified && donor.hasPassword);
        }
        if (passwordNew) {
          passwordNew.disabled = !emailVerified;
        }
        if (passwordConfirm) {
          passwordConfirm.disabled = !emailVerified;
        }
        if (passwordSave) {
          passwordSave.disabled = !emailVerified;
        }
        inviteEmail.value = donor.email || '';
        if (supportNameInput) {
          const preferredName = donor.name || donor.email || '';
          if (!supportNameInput.value) {
            supportNameInput.value = preferredName;
          }
          supportNameInput.placeholder = preferredName || 'Display name';
        }
        if (state.support.donorId !== donor.id) {
          state.support.donorId = donor.id;
          state.support.threads = [];
          state.support.activeThreadId = null;
          loadSupportThreads({ silent: true });
        }

        renderInvite(data.invite, limitReached, nextInviteAvailableAt, {
          emailVerified,
        });

        const inviteBlocked = !emailVerified || normalizedStatus !== 'active' || limitReached;
        if (inviteSubmit) {
          inviteSubmit.disabled = inviteBlocked;
        }
        if (inviteEmail) {
          inviteEmail.disabled = inviteBlocked;
        }
        if (inviteNote) {
          inviteNote.disabled = inviteBlocked;
        }

        if (!emailVerified) {
          inviteDescription.textContent =
            'Verify your email to unlock referral invites.';
        } else if (inviteBlocked && !limitReached) {
          inviteDescription.textContent = showSubscriptionCta
            ? 'Start your PayPal subscription to unlock referral invites.'
            : 'Referral invites unlock once your subscription is active.';
        }

        const identifier = donor.name || donor.email || donor.subscriptionId || '';
        if (identifier) {
          document.title = `Plex Dashboard • ${identifier}`;
        }
      }

      async function openDashboardSubscriptionCheckout() {
        if (!subscriptionButton || subscriptionButton.dataset.available !== 'true') {
          return;
        }

        subscriptionButton.disabled = true;
        subscriptionButton.textContent = 'Opening PayPal…';
        setStatusText(
          subscriptionNote,
          'Opening PayPal checkout in a new tab…',
          'info'
        );
        subscriptionNote.classList.add('small');

        const payload = {};
        const emailValue = profileEmail ? profileEmail.value.trim() : '';
        const nameValue = profileName ? profileName.value.trim() : '';
        if (emailValue) {
          payload.email = emailValue;
        }
        if (nameValue) {
          payload.name = nameValue;
        }

        const requestInit = {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        };

        let checkoutWindow = null;
        try {
          checkoutWindow = window.open('', '_blank');
          if (checkoutWindow) {
            try {
              checkoutWindow.opener = null;
            } catch (err) {
              // Ignore browsers that prevent direct assignment.
            }
          }
        } catch (err) {
          checkoutWindow = null;
        }

        try {
          const response = await sessionFetch('/api/customer/paypal-checkout', requestInit);
          let data;
          try {
            data = await response.json();
          } catch (err) {
            data = {};
          }

          updateSessionTokenFromResponse(data);

          if (!response.ok) {
            throw new Error(data.error || 'Unable to start PayPal checkout.');
          }

          if (data.approvalUrl) {
            let opened = false;
            if (checkoutWindow) {
              checkoutWindow.location = data.approvalUrl;
              opened = true;
            } else {
              const fallbackWindow = window.open(data.approvalUrl, '_blank');
              if (fallbackWindow) {
                opened = true;
                checkoutWindow = fallbackWindow;
                try {
                  fallbackWindow.opener = null;
                } catch (err) {
                  // Ignore browsers that prevent direct assignment.
                }
              }
            }

            if (!opened) {
              throw new Error(
                'Your browser blocked the PayPal checkout window. Allow pop-ups and try again.'
              );
            }
            setStatusText(
              subscriptionNote,
              'Follow the steps in the PayPal tab to complete your subscription.',
              'success'
            );
            subscriptionNote.classList.add('small');
          } else {
            throw new Error('PayPal did not return a checkout URL.');
          }
        } catch (err) {
          setStatusText(subscriptionNote, err.message, 'error');
          subscriptionNote.classList.add('small');
          if (checkoutWindow) {
            try {
              checkoutWindow.close();
            } catch (closeErr) {
              // Ignore close errors.
            }
          }
        } finally {
          subscriptionButton.disabled = false;
          subscriptionButton.textContent = defaultSubscriptionButtonLabel;
        }
      }

      async function fetchSession(options = {}) {
        const silent = options && options.silent;
        if (!silent) {
          showLoading();
        }
        try {
          const response = await sessionFetch('/api/customer/session');
          const payload = await response.json();
          updateSessionTokenFromResponse(payload);
          renderDashboard(payload);
        } catch (err) {
          showError(err.message);
        }
      }

      if (forgotPasswordLink) {
        forgotPasswordLink.addEventListener('click', (event) => {
          event.preventDefault();
          if (!forgotPasswordHelp) {
            return;
          }
          const isHidden = forgotPasswordHelp.classList.contains('hidden');
          if (isHidden) {
            forgotPasswordHelp.classList.remove('hidden');
            forgotPasswordLink.setAttribute('aria-expanded', 'true');
            forgotPasswordLink.textContent = 'Hide password help';
          } else {
            forgotPasswordHelp.classList.add('hidden');
            forgotPasswordLink.setAttribute('aria-expanded', 'false');
            forgotPasswordLink.textContent = defaultForgotPasswordLinkText;
          }
        });
      }

      if (changePasswordButton) {
        changePasswordButton.addEventListener('click', () => {
          if (passwordPanel) {
            passwordPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
          window.setTimeout(() => {
            if (passwordNew) {
              try {
                passwordNew.focus();
              } catch (err) {
                // Ignore focus errors.
              }
            }
          }, 200);
        });
      }

      if (passwordForm) {
        passwordForm.addEventListener('submit', async (event) => {
          event.preventDefault();
          if (!passwordSave) {
            return;
          }
          setStatusText(passwordStatus, 'Saving…', 'info');
          passwordSave.disabled = true;
          const payload = {
            currentPassword: passwordCurrent ? passwordCurrent.value : '',
            newPassword: passwordNew ? passwordNew.value : '',
            confirmPassword: passwordConfirm ? passwordConfirm.value : '',
          };

          try {
            const response = await sessionFetch('/api/customer/password', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });
            let responseBody;
            try {
              responseBody = await response.json();
            } catch (err) {
              responseBody = {};
            }
            updateSessionTokenFromResponse(responseBody);
            if (!response.ok) {
              throw new Error(responseBody.error || 'Failed to update password');
            }
            renderDashboard(responseBody);
            setStatusText(
              passwordStatus,
              'Password updated successfully.',
              'success'
            );
            if (passwordForm) {
              passwordForm.reset();
            }
          } catch (err) {
            setStatusText(passwordStatus, err.message, 'error');
          } finally {
            if (passwordSave) {
              passwordSave.disabled = false;
            }
          }
        });
      }

      loginForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        const email = loginEmail.value.trim();
        const password = loginPassword.value;

        if (!email || !password) {
          setStatusText(
            loginStatus,
            'Enter both your email and password to continue.',
            'error'
          );
          return;
        }

        setStatusText(loginStatus, 'Signing in…', 'info');
        loginButton.disabled = true;
        try {
          const response = await sessionFetch('/api/customer/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              email,
              password,
            }),
          });
          const payload = await response.json();
          updateSessionTokenFromResponse(payload);
          if (!response.ok) {
            throw new Error(payload.error || 'Unable to sign in');
          }
          setStatusText(loginStatus, 'Signed in successfully!', 'success');
          renderDashboard(payload);
          loginPassword.value = '';
        } catch (err) {
          setStatusText(loginStatus, err.message, 'error');
        } finally {
          loginButton.disabled = false;
        }
      });

      logoutButton.addEventListener('click', async () => {
        logoutButton.disabled = true;
        try {
          await sessionFetch('/api/customer/logout', { method: 'POST' });
          renderDashboard({ authenticated: false });
        } catch (err) {
          // ignore logout errors and show login anyway
          renderDashboard({ authenticated: false });
        } finally {
          setSessionToken(null);
          logoutButton.disabled = false;
        }
      });

      if (subscriptionButton) {
        subscriptionButton.addEventListener('click', async (event) => {
          event.preventDefault();
          if (subscriptionButton.disabled || subscriptionButton.dataset.available !== 'true') {
            return;
          }
          await openDashboardSubscriptionCheckout();
        });
      }

      if (plexLinkButton) {
        plexLinkButton.addEventListener('click', async () => {
          if (plexLinkButton.disabled) {
            return;
          }

          setPlexLinkStatus('Starting Plex authentication…', 'info', {
            force: true,
          });
          plexLinkButton.disabled = true;
          clearPlexLinkPollTimer();
          clearPlexLinkCountdownTimer();
          closePlexAuthWindow();
          state.pendingPlexLink = null;

          let authWindow = null;
          try {
            authWindow = window.open('', '_blank');
            if (authWindow) {
              try {
                authWindow.opener = null;
              } catch (err) {
                // Ignore browsers that prevent direct assignment.
              }
            }
          } catch (err) {
            authWindow = null;
          }

          let responseData = null;
          try {
            const response = await sessionFetch('/api/customer/plex/link/start', {
              method: 'POST',
            });
            try {
              responseData = await response.json();
            } catch (err) {
              responseData = {};
            }
            updateSessionTokenFromResponse(responseData);
            if (!response.ok) {
              throw new Error(
                (responseData && responseData.error) ||
                  'Failed to start Plex authentication. Try again shortly.'
              );
            }

            renderDashboard(responseData);

            const authUrl =
              responseData &&
              responseData.plexLink &&
              responseData.plexLink.authUrl
                ? responseData.plexLink.authUrl
                : '';

            if (authUrl) {
              let opened = false;
              if (authWindow) {
                authWindow.location = authUrl;
                plexLinkAuthWindow = authWindow;
                opened = true;
              } else {
                const fallbackWindow = window.open(authUrl, '_blank');
                if (fallbackWindow) {
                  opened = true;
                  plexLinkAuthWindow = fallbackWindow;
                  try {
                    fallbackWindow.opener = null;
                  } catch (err) {
                    // Ignore browsers that prevent direct assignment.
                  }
                }
              }

              if (!opened) {
                throw new Error(
                  'Your browser blocked the Plex authentication window. Allow pop-ups and try again.'
                );
              }
            } else if (authWindow) {
              try {
                authWindow.close();
              } catch (err) {
                // Ignore window close errors.
              }
              plexLinkAuthWindow = null;
            }
          } catch (err) {
            if (authWindow) {
              try {
                authWindow.close();
              } catch (closeErr) {
                // Ignore window close errors.
              }
            }
            plexLinkAuthWindow = null;
            setPlexLinkStatus(err.message || 'Failed to start Plex authentication.', 'error', {
              sticky: true,
              force: true,
            });
            plexLinkButton.disabled = false;
            plexLinkButton.classList.remove('hidden');
            clearPlexLinkCountdownTimer();
            clearPlexLinkPollTimer();
            state.pendingPlexLink = null;
            if (plexLinkPin) {
              plexLinkPin.classList.add('hidden');
            }
            if (plexLinkPinCode) {
              plexLinkPinCode.textContent = '----';
            }
            if (plexLinkPinExpiry) {
              plexLinkPinExpiry.textContent = '';
            }
          }
        });
      }

      if (supportToggle && supportContainer) {
        supportToggle.addEventListener('click', async () => {
          await setSupportPanelOpen(!supportPanelOpen);
        });
      }

      if (supportForm) {
        supportForm.addEventListener('submit', async (event) => {
          event.preventDefault();
          if (supportSubmit) {
            supportSubmit.disabled = true;
          }
          setStatusText(supportStatus, 'Sending support request…', 'info');
          try {
            const response = await sessionFetch('/api/customer/support', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                subject: supportSubjectInput ? supportSubjectInput.value.trim() : '',
                message: supportMessageInput ? supportMessageInput.value.trim() : '',
                displayName: supportNameInput ? supportNameInput.value.trim() : '',
              }),
            });
            const payload = await response.json();
            updateSessionTokenFromResponse(payload);
            if (!response.ok) {
              throw new Error(
                (payload && payload.error) || 'Failed to submit support request.'
              );
            }
            if (supportSubjectInput) {
              supportSubjectInput.value = '';
            }
            if (supportMessageInput) {
              supportMessageInput.value = '';
            }
            setStatusText(
              supportStatus,
              'Support request sent! We will email you when we respond.',
              'success'
            );
            if (payload && payload.thread && payload.thread.request) {
              state.support.activeThreadId = payload.thread.request.id;
            }
            await loadSupportThreads({ silent: true });
          } catch (err) {
            setStatusText(
              supportStatus,
              err && err.message ? err.message : 'Failed to submit support request.',
              'error'
            );
          } finally {
            if (supportSubmit) {
              supportSubmit.disabled = false;
            }
          }
        });
      }

      if (supportReplyForm) {
        supportReplyForm.addEventListener('submit', async (event) => {
          event.preventDefault();
          const activeThreadId = state.support.activeThreadId;
          if (!activeThreadId) {
            setStatusText(
              supportReplyStatus,
              'Select a support request first.',
              'error'
            );
            return;
          }
          const messageValue = supportReplyMessage
            ? supportReplyMessage.value.trim()
            : '';
          if (!messageValue) {
            setStatusText(supportReplyStatus, 'Enter a reply before sending.', 'error');
            return;
          }
          if (supportReplySubmit) {
            supportReplySubmit.disabled = true;
          }
          setStatusText(supportReplyStatus, 'Sending reply…', 'info');
          try {
            const response = await sessionFetch(
              `/api/customer/support/${activeThreadId}/replies`,
              {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  message: messageValue,
                  displayName: supportNameInput ? supportNameInput.value.trim() : '',
                }),
              }
            );
            const payload = await response.json();
            updateSessionTokenFromResponse(payload);
            if (!response.ok) {
              throw new Error((payload && payload.error) || 'Failed to send reply.');
            }
            if (payload && payload.thread && payload.thread.request) {
              state.support.activeThreadId = payload.thread.request.id;
            }
            setStatusText(supportReplyStatus, 'Reply sent!', 'success');
            await loadSupportThreads({ silent: true });
          } catch (err) {
            setStatusText(
              supportReplyStatus,
              err && err.message ? err.message : 'Failed to send reply.',
              'error'
            );
          } finally {
            if (supportReplySubmit) {
              supportReplySubmit.disabled = false;
            }
          }
        });
      }

      profileForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        setStatusText(profileStatus, 'Saving…', 'info');
        profileSave.disabled = true;
        try {
          const response = await sessionFetch('/api/customer/profile', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              email: profileEmail.value.trim(),
              name: profileName.value.trim(),
              subscriptionId: profileSubscription
                ? profileSubscription.value.trim()
                : '',
            }),
          });
          const payload = await response.json();
          updateSessionTokenFromResponse(payload);
          if (!response.ok) {
            throw new Error(payload.error || 'Failed to update profile');
          }
          setStatusText(profileStatus, 'Profile updated', 'success');
          renderDashboard(payload);
        } catch (err) {
          setStatusText(profileStatus, err.message, 'error');
        } finally {
          profileSave.disabled = false;
        }
      });

      inviteForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        if (
          inviteSubmit.disabled ||
          (inviteForm && inviteForm.classList.contains('hidden')) ||
          (state.data && state.data.inviteLimitReached)
        ) {
          return;
        }
        setStatusText(inviteStatus, 'Sending referral invite…', 'info');
        inviteSubmit.disabled = true;
        let responseData = null;
        try {
          const response = await sessionFetch('/api/customer/invite', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              email: inviteEmail.value.trim(),
              note: inviteNote.value.trim(),
            }),
          });
          const payload = await response.json();
          responseData = payload;
          updateSessionTokenFromResponse(payload);
          if (!response.ok) {
            if (payload && payload.payload) {
              renderDashboard(payload.payload);
            }
            throw new Error(payload.error || 'Failed to send referral invite');
          }
          setStatusText(
            inviteStatus,
            'Referral invite ready! Share the link below—or follow it yourself if you’re restoring access.',
            'success'
          );
          inviteNote.value = '';
          renderDashboard(payload);
        } catch (err) {
          setStatusText(inviteStatus, err.message, 'error');
        } finally {
          const limitHit = Boolean(
            (responseData && responseData.inviteLimitReached) ||
              (state.data && state.data.inviteLimitReached)
          );
          if (!limitHit) {
            inviteSubmit.disabled = false;
          }
        }
      });

      if (initialVerificationToken) {
        submitVerificationToken(initialVerificationToken);
      } else {
        fetchSession();
      }
    </script>
  </body>
</html>
