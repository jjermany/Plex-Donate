<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#050818" />
    <meta name="msapplication-TileColor" content="#0f172a" />
    <meta name="msapplication-TileImage" content="/icons/plex-donate-android-any-144.png" />
    <meta name="application-name" content="Plex Donate" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="Plex Donate" />
    <link rel="manifest" href="/manifest.webmanifest" />
    <link rel="icon" type="image/png" sizes="144x144" href="/icons/plex-donate-android-any-144.png" />
    <link rel="icon" type="image/png" sizes="192x192" href="/icons/plex-donate-android-any-192.png" />
    <link rel="icon" type="image/png" sizes="512x512" href="/icons/plex-donate-android-any-512.png" />
    <link rel="shortcut icon" href="/icons/plex-donate-android-any-144.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/icons/plex-donate-ios-120.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/icons/plex-donate-ios-152.png" />
    <link rel="apple-touch-icon" sizes="167x167" href="/icons/plex-donate-ios-167.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/plex-donate-ios-180.png" />

    <title>Plex Donate Dashboard</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI',
          sans-serif;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(
            120% 120% at 50% -10%,
            rgba(99, 102, 241, 0.35) 0%,
            rgba(15, 23, 42, 0.92) 45%,
            #050818 100%
          ),
          radial-gradient(80% 80% at 80% 20%, rgba(14, 165, 233, 0.18), transparent);
        color: #e2e8f0;
        display: flex;
        justify-content: center;
        padding: 32px 16px 64px;
        position: relative;
      }
      body::after {
        content: '';
        position: fixed;
        inset: 0;
        background: radial-gradient(
          60% 60% at 20% 20%,
          rgba(76, 29, 149, 0.18),
          transparent 70%
        );
        pointer-events: none;
        z-index: 0;
      }
      a {
        color: inherit;
      }
      h1,
      h2,
      h3 {
        margin: 0;
      }
      h1 {
        font-size: clamp(2.2rem, 4vw, 3rem);
        line-height: 1.1;
        background: linear-gradient(135deg, #c7d2fe 0%, #a855f7 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }
      h2 {
        font-size: clamp(1.4rem, 2vw, 1.8rem);
        line-height: 1.3;
      }
      p {
        margin: 0;
        line-height: 1.6;
      }
      .hidden {
        display: none !important;
      }
      [hidden] {
        display: none !important;
      }
      .panel {
        width: min(780px, 100%);
        background: rgba(15, 23, 42, 0.82);
        border: 1px solid rgba(148, 163, 184, 0.3);
        border-radius: 20px;
        padding: 28px;
        text-align: center;
        box-shadow: 0 25px 60px -25px rgba(30, 64, 175, 0.6);
        position: relative;
        z-index: 1;
      }
      .panel.error {
        background: rgba(76, 29, 149, 0.18);
        border-color: rgba(248, 113, 113, 0.4);
        color: #fecdd3;
      }
      #app {
        width: min(960px, 100%);
        position: relative;
        z-index: 1;
      }
      .canvas {
        display: grid;
        gap: 28px;
      }
      .dashboard-tabs {
        display: grid;
        gap: 24px;
      }
      .dashboard-legend {
        position: sticky;
        top: 16px;
        z-index: 2;
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 8px;
        padding: 10px;
        border-radius: 16px;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 23, 42, 0.78);
        box-shadow: 0 20px 50px -28px rgba(79, 70, 229, 0.55);
        backdrop-filter: blur(18px);
      }
      .dashboard-legend-button {
        appearance: none;
        border: none;
        border-radius: 12px;
        padding: 10px 18px;
        font-weight: 600;
        font-size: 0.95rem;
        color: rgba(203, 213, 225, 0.85);
        background: transparent;
        cursor: pointer;
        transition: color 0.2s ease, background 0.2s ease,
          box-shadow 0.2s ease, transform 0.2s ease;
      }
      .dashboard-legend-button:hover,
      .dashboard-legend-button:focus-visible {
        color: #c7d2fe;
        background: rgba(99, 102, 241, 0.14);
        outline: none;
      }
      .dashboard-legend-button.is-active,
      .dashboard-legend-button[aria-selected='true'] {
        background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
        color: #ffffff;
        box-shadow: 0 18px 36px -24px rgba(79, 70, 229, 0.9);
        transform: translateY(-1px);
      }
      .dashboard-legend-button.is-active:focus-visible,
      .dashboard-legend-button[aria-selected='true']:focus-visible {
        outline: 2px solid rgba(199, 210, 254, 0.85);
        outline-offset: 2px;
      }
      .dashboard-tabpanels {
        display: grid;
        gap: 24px;
      }
      .dashboard-tabpanel {
        display: grid;
        gap: 24px;
      }
      .dashboard-tabpanel:focus-visible {
        outline: 2px solid rgba(129, 140, 248, 0.6);
        outline-offset: 4px;
      }
      .surface {
        background: rgba(15, 23, 42, 0.76);
        border: 1px solid rgba(148, 163, 184, 0.22);
        border-radius: 24px;
        padding: clamp(24px, 4vw, 36px);
        box-shadow: 0 30px 60px -28px rgba(37, 99, 235, 0.55);
        backdrop-filter: blur(18px);
      }
      .trial-panel-header {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 18px;
        flex-wrap: wrap;
      }
      .trial-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 6px 14px;
        border-radius: 999px;
        font-weight: 600;
        font-size: 0.85rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.35), rgba(139, 92, 246, 0.55));
        color: #eef2ff;
        border: 1px solid rgba(165, 180, 252, 0.45);
        box-shadow: 0 18px 40px -28px rgba(99, 102, 241, 0.9);
      }
      .trial-countdown {
        margin-top: 24px;
        display: flex;
        flex-wrap: wrap;
        gap: 28px;
        align-items: stretch;
        justify-content: space-between;
      }
      .trial-countdown-time {
        flex: 1 1 180px;
        min-width: 160px;
        max-width: 220px;
        display: grid;
        gap: 12px;
        justify-items: center;
        padding: 20px;
        border-radius: 20px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(30, 41, 59, 0.65);
        box-shadow: inset 0 1px 0 rgba(148, 163, 184, 0.15);
      }
      .trial-countdown-value {
        font-size: clamp(2.6rem, 6vw, 3.4rem);
        font-weight: 700;
        line-height: 1;
        color: #c7d2fe;
      }
      .trial-countdown-label {
        font-size: 0.8rem;
        font-weight: 600;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: rgba(203, 213, 225, 0.8);
      }
      .trial-countdown-details {
        flex: 2 1 260px;
        display: grid;
        gap: 12px;
      }
      .trial-countdown-details strong {
        color: #e0e7ff;
      }
      .trial-countdown-highlight {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        border-radius: 999px;
        background: rgba(79, 70, 229, 0.2);
        border: 1px solid rgba(165, 180, 252, 0.35);
        color: rgba(226, 232, 240, 0.92);
        font-size: 0.85rem;
        font-weight: 600;
        width: fit-content;
      }
      .support-container {
        margin-top: 20px;
        display: grid;
        gap: 20px;
        text-align: left;
      }
      .support-wrapper {
        display: grid;
        gap: 24px;
      }
      .support-form {
        display: grid;
        gap: 12px;
      }
      .support-form label {
        font-size: 0.85rem;
        color: rgba(203, 213, 225, 0.85);
      }
      .support-form input,
      .support-form textarea {
        width: 100%;
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(15, 23, 42, 0.6);
        color: inherit;
        padding: 12px 14px;
        font-size: 1rem;
        font-family: inherit;
      }
      .support-form textarea {
        resize: vertical;
        min-height: 120px;
      }
      .support-actions {
        display: grid;
        gap: 12px;
      }
      .support-threads {
        display: grid;
        gap: 18px;
      }
      .support-thread-list {
        display: grid;
        gap: 10px;
      }
      .support-thread-button {
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 23, 42, 0.65);
        border-radius: 14px;
        padding: 14px 16px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        transition: border-color 0.15s ease, background 0.15s ease;
      }
      .support-thread-button:hover,
      .support-thread-button[aria-current='true'] {
        border-color: rgba(165, 180, 252, 0.6);
        background: rgba(79, 70, 229, 0.24);
      }
      .support-thread-button h3 {
        margin: 0;
        font-size: 1rem;
      }
      .support-status-pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }
      .support-status-open {
        background: rgba(34, 197, 94, 0.2);
        color: #bbf7d0;
      }
      .support-status-resolved {
        background: rgba(148, 163, 184, 0.2);
        color: rgba(226, 232, 240, 0.8);
      }
      .support-thread-detail {
        border: 1px solid rgba(148, 163, 184, 0.25);
        border-radius: 16px;
        padding: 18px;
        background: rgba(15, 23, 42, 0.5);
        display: grid;
        gap: 18px;
      }
      .support-messages {
        display: grid;
        gap: 12px;
        max-height: 320px;
        overflow-y: auto;
        padding-right: 4px;
      }
      .support-message {
        border-radius: 14px;
        border: 1px solid rgba(148, 163, 184, 0.25);
        padding: 12px 14px;
        background: rgba(30, 41, 59, 0.65);
        display: grid;
        gap: 6px;
      }
      .support-message[data-author='admin'] {
        border-color: rgba(129, 140, 248, 0.45);
        background: rgba(79, 70, 229, 0.28);
      }
      .support-message-author {
        font-weight: 600;
        font-size: 0.9rem;
      }
      .support-message-meta {
        font-size: 0.75rem;
        color: rgba(203, 213, 225, 0.7);
      }
      .support-empty {
        font-size: 0.9rem;
        color: rgba(203, 213, 225, 0.7);
      }
      .support-toggle {
        width: fit-content;
        justify-self: center;
      }
      .hero {
        position: relative;
        overflow: hidden;
        display: grid;
        gap: 16px;
        text-align: center;
      }
      .hero::after {
        content: '';
        position: absolute;
        inset: -40% 40% auto -30%;
        height: 120%;
        transform: rotate(18deg);
        background: radial-gradient(
          60% 60% at 50% 50%,
          rgba(59, 130, 246, 0.3),
          transparent 70%
        );
        z-index: 0;
      }
      .hero > * {
        position: relative;
        z-index: 1;
      }
      .eyebrow {
        letter-spacing: 0.2em;
        text-transform: uppercase;
        font-size: 0.75rem;
        color: rgba(165, 180, 252, 0.9);
      }
      .muted {
        color: rgba(203, 213, 225, 0.8);
      }
      .small {
        font-size: 0.85rem;
      }
      .status-text {
        font-size: 0.9rem;
        margin-top: 12px;
        color: rgba(165, 180, 252, 0.9);
      }
      .status-text.error {
        color: #fca5a5;
      }
      .status-text.success {
        color: #bbf7d0;
      }
      .status-text.info {
        color: #c7d2fe;
      }
      .link-inline {
        color: #c7d2fe;
        text-decoration: underline;
        font-weight: 600;
        cursor: pointer;
      }
      .link-inline:hover {
        text-decoration: none;
      }
      .announcement-banner {
        --announcement-bg: rgba(99, 102, 241, 0.22);
        --announcement-border: rgba(129, 140, 248, 0.45);
        --announcement-chip-bg: rgba(129, 140, 248, 0.35);
        --announcement-chip-color: #c7d2fe;
        --announcement-text: #e2e8f0;
        border-radius: 20px;
        border: 1px solid var(--announcement-border);
        padding: 20px;
        background: var(--announcement-bg);
        color: var(--announcement-text);
        box-shadow: 0 25px 50px -30px rgba(99, 102, 241, 0.8);
        display: grid;
        gap: 14px;
      }
      .announcement-banner[data-tone='success'] {
        --announcement-bg: rgba(34, 197, 94, 0.24);
        --announcement-border: rgba(74, 222, 128, 0.45);
        --announcement-chip-bg: rgba(74, 222, 128, 0.35);
        --announcement-chip-color: #bbf7d0;
      }
      .announcement-banner[data-tone='warning'] {
        --announcement-bg: rgba(234, 179, 8, 0.28);
        --announcement-border: rgba(250, 204, 21, 0.45);
        --announcement-chip-bg: rgba(250, 204, 21, 0.35);
        --announcement-chip-color: #fde68a;
      }
      .announcement-banner[data-tone='danger'] {
        --announcement-bg: rgba(248, 113, 113, 0.28);
        --announcement-border: rgba(252, 165, 165, 0.45);
        --announcement-chip-bg: rgba(252, 165, 165, 0.4);
        --announcement-chip-color: #fecdd3;
      }
      .announcement-banner[data-tone='neutral'] {
        --announcement-bg: rgba(71, 85, 105, 0.45);
        --announcement-border: rgba(148, 163, 184, 0.4);
        --announcement-chip-bg: rgba(148, 163, 184, 0.45);
        --announcement-chip-color: #e2e8f0;
      }
      .announcement-banner h2,
      .announcement-banner h3,
      .announcement-banner p {
        margin: 0;
      }
      .announcement-banner p {
        white-space: pre-wrap;
      }
      .announcement-banner-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      .announcement-chip {
        display: inline-flex;
        align-items: center;
        padding: 4px 12px;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        background: var(--announcement-chip-bg);
        color: var(--announcement-chip-color);
      }
      .announcement-dismiss {
        border: none;
        background: transparent;
        color: inherit;
        font-size: 0.85rem;
        opacity: 0.75;
        cursor: pointer;
      }
      .announcement-actions {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }
      .announcement-cta {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 10px 18px;
        border-radius: 999px;
        font-weight: 600;
        background: rgba(148, 163, 184, 0.25);
        color: inherit;
        text-decoration: none;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }
      .announcement-cta:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 30px -22px rgba(148, 163, 184, 0.8);
      }
      .login-footnote {
        margin: -6px 0 0;
      }
      .helper-text {
        color: rgba(203, 213, 225, 0.8);
        font-size: 0.9rem;
      }
      form {
        display: grid;
        gap: 16px;
        margin-top: 20px;
        text-align: left;
      }
      label {
        display: grid;
        gap: 8px;
        font-weight: 600;
        color: #cbd5f5;
      }
      input {
        width: 100%;
        padding: 12px 14px;
        border-radius: 12px;
        border: 1px solid rgba(129, 140, 248, 0.4);
        background: rgba(15, 23, 42, 0.7);
        color: inherit;
        font-size: 1rem;
      }
      input:focus {
        outline: 2px solid rgba(129, 140, 248, 0.8);
        outline-offset: 2px;
      }
      button {
        appearance: none;
        border: none;
        border-radius: 999px;
        padding: 12px 22px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }
      button:disabled {
        cursor: not-allowed;
        opacity: 0.6;
      }
      .button-link {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        border-radius: 999px;
        padding: 12px 22px;
        font-size: 1rem;
        font-weight: 600;
        text-decoration: none;
        transition: transform 0.2s ease, box-shadow 0.2s ease,
          opacity 0.2s ease;
      }
      .button-link:hover {
        transform: translateY(-1px);
      }
      .button-primary {
        background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
        color: #ffffff;
        box-shadow: 0 12px 30px -12px rgba(79, 70, 229, 0.65);
      }
      .button-secondary {
        background: rgba(148, 163, 184, 0.2);
        color: #e2e8f0;
        border: 1px solid rgba(148, 163, 184, 0.4);
      }
      .plex-link-controls {
        display: grid;
        gap: 12px;
        margin-top: 16px;
        justify-items: start;
        align-items: start;
      }
      .plex-link-controls .button-primary {
        width: fit-content;
      }
      .plex-link-pin {
        display: grid;
        gap: 6px;
        padding: 14px 18px;
        border-radius: 14px;
        background: rgba(79, 70, 229, 0.18);
        border: 1px solid rgba(165, 180, 252, 0.35);
        font-variant-numeric: tabular-nums;
        max-width: min(320px, 100%);
      }
      .plex-link-pin-code {
        font-size: 1.9rem;
        font-weight: 700;
        letter-spacing: 0.12em;
      }
      .plex-link-pin-expiry {
        font-size: 0.85rem;
        color: rgba(203, 213, 225, 0.85);
      }
      .header-actions {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
        align-items: center;
      }
      .grid {
        display: grid;
        gap: 24px;
      }
      @media (min-width: 900px) {
        .grid-columns-2 {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }

      /* Mobile-friendly responsive design */
      @media (max-width: 768px) {
        /* Stack buttons vertically on mobile */
        .header-actions {
          flex-direction: column;
          align-items: stretch;
          width: 100%;
        }

        .header-actions button,
        .cta-actions button {
          width: 100%;
        }

        /* Stack dashboard legend buttons for better mobile fit */
        .dashboard-legend {
          position: static;
        }

        .dashboard-legend-button {
          padding: 8px 14px;
          font-size: 0.88rem;
        }

        /* Adjust trial countdown for mobile */
        .trial-countdown {
          flex-direction: column;
          align-items: stretch;
          gap: 16px;
        }

        .trial-countdown-time,
        .trial-countdown-details {
          flex: 1 1 auto;
          min-width: auto;
          max-width: 100%;
        }

        /* Reduce padding on smaller screens */
        .surface {
          padding: 20px;
        }

        /* Handle profile-summary stacking */
        .profile-summary {
          flex-direction: column;
          align-items: flex-start;
        }

        /* Ensure support message form is mobile-friendly */
        .support-message-form {
          padding: 16px;
        }
      }

      @media (max-width: 480px) {
        /* Extra small mobile devices */
        .dashboard-legend-button {
          padding: 8px 12px;
          font-size: 0.85rem;
        }

        .surface {
          padding: 16px;
        }
      }
      .profile-summary {
        display: flex;
        justify-content: space-between;
        gap: 16px;
        flex-wrap: wrap;
        align-items: center;
      }
      .status-pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 14px;
        border-radius: 999px;
        font-size: 0.82rem;
        font-weight: 600;
        background: rgba(59, 130, 246, 0.24);
        color: #bfdbfe;
        text-transform: capitalize;
      }
      .status-pill[data-status='active'] {
        background: rgba(34, 197, 94, 0.22);
        color: #bbf7d0;
      }
      .status-pill[data-status='cancelled'],
      .status-pill[data-status='suspended'],
      .status-pill[data-status='expired'] {
        background: rgba(248, 113, 113, 0.24);
        color: #fecdd3;
      }
      .detail-list {
        display: grid;
        gap: 12px;
        margin-top: 20px;
      }
      .detail {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
        font-size: 0.95rem;
      }
      .detail .label {
        color: rgba(148, 163, 184, 0.9);
        font-weight: 600;
      }
      .invite-ready {
        margin-top: 24px;
        border-radius: 18px;
        border: 1px solid rgba(129, 140, 248, 0.4);
        padding: 18px;
        background: rgba(79, 70, 229, 0.15);
        text-align: left;
        display: grid;
        gap: 12px;
      }
      .invite-link {
        word-break: break-all;
        color: #c7d2fe;
        text-decoration: underline;
      }
      .badge {
        display: inline-flex;
        align-items: center;
        padding: 4px 10px;
        border-radius: 999px;
        font-weight: 600;
        font-size: 0.8rem;
      }
      .badge.success {
        background: rgba(34, 197, 94, 0.28);
        color: #bbf7d0;
      }
      .login-card {
        display: grid;
        gap: 16px;
        text-align: left;
      }
      .cta-actions {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
      }
      .subscription-cta {
        margin-top: 18px;
        display: grid;
        gap: 8px;
        justify-items: start;
      }
      .subscription-cta .button-primary {
        text-decoration: none;
        text-align: center;
      }
      .onboarding {
        display: grid;
        gap: 20px;
        text-align: left;
      }
      .request-list {
        margin: 16px 0;
        padding-left: 1.2rem;
        display: grid;
        gap: 8px;
      }
      .steps {
        display: grid;
        gap: 16px;
      }
      .step {
        border: 1px solid rgba(148, 163, 184, 0.28);
        border-radius: 20px;
        padding: 18px 20px;
        background: rgba(15, 23, 42, 0.66);
        transition: border-color 0.2s ease, box-shadow 0.2s ease,
          background 0.2s ease, transform 0.2s ease;
      }
      .step-header {
        display: flex;
        align-items: center;
        gap: 14px;
      }
      .step-header > div {
        display: grid;
        gap: 6px;
      }
      .step-number {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 40px;
        height: 40px;
        border-radius: 999px;
        background: rgba(99, 102, 241, 0.25);
        color: #c7d2fe;
        font-weight: 700;
        font-size: 1.1rem;
        flex-shrink: 0;
      }
      .step-title {
        margin: 0;
        font-size: 1.1rem;
        font-weight: 600;
      }
      .step-footnote {
        margin-top: 12px;
      }
      .step[data-state='complete'] {
        border-color: rgba(34, 197, 94, 0.45);
        background: rgba(21, 128, 61, 0.18);
      }
      .step[data-state='complete'] .step-number {
        background: rgba(34, 197, 94, 0.35);
        color: #bbf7d0;
      }
      .step[data-state='current'] {
        border-color: rgba(129, 140, 248, 0.8);
        background: rgba(79, 70, 229, 0.2);
        box-shadow: 0 18px 40px -28px rgba(99, 102, 241, 0.9);
        transform: translateY(-2px);
      }
      .step[data-state='current'] .step-number {
        background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
        color: #ffffff;
      }
      .step[data-state='upcoming'] {
        opacity: 0.92;
      }
      .step[data-state='upcoming'] .step-number {
        background: rgba(100, 116, 139, 0.25);
        color: rgba(203, 213, 225, 0.8);
      }
      .password-guidance {
        margin-top: -4px;
      }
      .section-title {
        font-size: 1.2rem;
        font-weight: 600;
      }
      ul {
        margin: 0;
        padding-left: 20px;
        display: grid;
        gap: 8px;
      }
    </style>
  </head>
  <body>
    <div id="loading" class="panel">Loading your dashboard…</div>
    <div id="error-panel" class="panel error hidden"></div>
    <div id="app" class="hidden">
      <main class="canvas">
        <section class="surface hero">
          <span class="eyebrow">Plex Donate</span>
          <h1>You're just steps away from endless Plex adventures</h1>
          <p class="muted">
            Signed up through one of our share links? Use the account you
            created there to manage invites, keep your details current, and
            jump back into your libraries anytime. Not subscribed yet? Follow
            the guided checklist below to unlock access to endless content.
          </p>
        </section>

        <section
          id="announcement-banner"
          class="announcement-banner hidden"
          role="status"
          aria-live="polite"
          data-tone="info"
        >
          <div class="announcement-banner-header">
            <span class="announcement-chip" id="announcement-chip">Information</span>
            <button
              type="button"
              class="announcement-dismiss"
              id="announcement-dismiss"
              aria-label="Dismiss announcement"
            >
              Dismiss
            </button>
          </div>
          <h2 id="announcement-title">Banner title</h2>
          <p id="announcement-body"></p>
          <div class="announcement-actions">
            <a
              id="announcement-cta"
              class="announcement-cta hidden"
              href="#"
              target="_blank"
              rel="noopener"
            ></a>
          </div>
        </section>

        <section id="login-panel" class="surface login-card">
          <div>
            <span class="section-title">Customer sign-in</span>
            <p class="muted small">
              Use the same credentials you saved on the invite page. If you're
              just getting started, head back to your share link to complete
              step one.
            </p>
          </div>
          <form id="login-form">
            <label>
              <span>Email on file</span>
              <input
                id="login-email"
                type="email"
                placeholder="you@example.com"
                autocomplete="email"
                required
              />
            </label>
            <label>
              <span>Password</span>
              <input
                id="login-password"
                type="password"
                placeholder="••••••••"
                autocomplete="current-password"
                required
              />
            </label>
            <div class="cta-actions">
              <button id="login-button" type="submit" class="button-primary">
                Sign in
              </button>
              <p id="login-status" class="status-text"></p>
            </div>
          </form>
          <p class="muted small login-footnote">
            <a
              id="forgot-password-link"
              class="link-inline"
              href="#"
              aria-controls="forgot-password-help"
              aria-expanded="false"
              >Forgot your password?</a
            >
          </p>
          <p id="forgot-password-help" class="muted small hidden helper-text">
            Donor accounts can request a fresh invite email from your share link
            to set a new password. Need a hand? Reach out to the server admin
            and they'll help you get back to streaming in no time.
          </p>
        </section>

        <section id="dashboard-panel" class="dashboard-tabs hidden">
          <nav
            class="dashboard-legend"
            aria-label="Dashboard sections"
            data-dashboard-tablist
            role="tablist"
          >
            <button
              id="dashboard-tab-account"
              type="button"
              class="dashboard-legend-button is-active"
              role="tab"
              aria-selected="true"
              aria-controls="dashboard-tabpanel-account"
              data-dashboard-tab="account"
              tabindex="0"
            >
              Account
            </button>
            <button
              id="dashboard-tab-plex"
              type="button"
              class="dashboard-legend-button"
              role="tab"
              aria-selected="false"
              aria-controls="dashboard-tabpanel-plex"
              data-dashboard-tab="plex"
              tabindex="-1"
            >
              Plex setup
            </button>
            <button
              id="dashboard-tab-support"
              type="button"
              class="dashboard-legend-button"
              role="tab"
              aria-selected="false"
              aria-controls="dashboard-tabpanel-support"
              data-dashboard-tab="support"
              tabindex="-1"
            >
              Support
            </button>
            <button
              id="dashboard-tab-resources"
              type="button"
              class="dashboard-legend-button"
              role="tab"
              aria-selected="false"
              aria-controls="dashboard-tabpanel-resources"
              data-dashboard-tab="resources"
              tabindex="-1"
            >
              Resources
            </button>
          </nav>

          <div class="dashboard-tabpanels">
            <section
              id="dashboard-tabpanel-account"
              class="dashboard-tabpanel"
              role="tabpanel"
              aria-labelledby="dashboard-tab-account"
              data-dashboard-panel="account"
              tabindex="0"
            >
              <article class="surface">
                <div class="profile-summary">
                  <div>
                    <h2 class="section-title">Your membership</h2>
                    <p id="member-name" class="muted"></p>
                    <p id="member-email" class="muted"></p>
                  </div>
                  <div class="header-actions">
                    <span
                      id="member-status"
                      class="status-pill"
                      data-status="pending"
                      >pending</span
                    >
                    <button
                      id="change-password-button"
                      class="button-secondary"
                      type="button"
                    >
                      Change password
                    </button>
                    <button id="logout-button" class="button-secondary" type="button">
                      Sign out
                    </button>
                  </div>
                </div>
                <div class="detail-list">
                  <div id="member-plan" class="detail hidden"></div>
                  <div id="member-subscription-row" class="detail hidden">
                    <span class="label">Subscription ID</span>
                    <span id="member-subscription-id"></span>
                  </div>
                  <div id="member-last-payment-row" class="detail hidden">
                    <span class="label">Last payment</span>
                    <span id="member-last-payment"></span>
                  </div>
                </div>
                <p
                  id="member-status-message"
                  class="status-text small"
                  aria-live="polite"
                ></p>
                <div id="subscription-cta" class="subscription-cta hidden">
                  <button id="trial-button" class="button-secondary" type="button">
                    Start 7-day trial
                  </button>
                  <button id="subscription-button" class="button-primary" type="button">
                    Start subscription
                  </button>
                  <button id="stripe-checkout-dashboard-button" class="button-primary hidden" type="button">
                    Subscribe with Stripe
                  </button>
                  <button id="stripe-billing-portal-button" class="button-primary hidden" type="button">
                    Manage Stripe Billing
                  </button>
                  <p id="subscription-note" class="status-text small">
                    Choose your payment method to get started.
                  </p>
                  <p id="stripe-portal-status" class="status-text small hidden"></p>
                  <p id="trial-status" class="status-text"></p>
                </div>
              </article>

              <article id="trial-panel" class="surface hidden" hidden>
                <div class="trial-panel-header">
                  <div>
                    <h2 class="section-title">Free trial countdown</h2>
                    <p class="muted small">
                      Upgrade before the countdown ends to keep streaming without
                      interruption.
                    </p>
                  </div>
                  <span class="trial-badge">Trial</span>
                </div>
                <div class="trial-countdown">
                  <div class="trial-countdown-time">
                    <span id="trial-days-remaining" class="trial-countdown-value">0</span>
                    <span id="trial-days-label" class="trial-countdown-label"
                      >days remaining</span
                    >
                  </div>
                  <div class="trial-countdown-details">
                    <span class="trial-countdown-highlight">
                      Trial ends on <strong id="trial-end-date">—</strong>
                    </span>
                    <p id="trial-countdown-detail" class="muted small"></p>
                  </div>
                </div>
              </article>

              <article class="surface">
                <h2 class="section-title">Update your profile</h2>
                <p class="muted">
                  Keep your preferred streaming email and display name current so we
                  can reach you when new invites are generated.
                </p>
                <form id="profile-form">
                  <label>
                    <span>Streaming email</span>
                    <input
                      id="profile-email"
                      type="email"
                      placeholder="you@example.com"
                      autocomplete="email"
                      required
                    />
                  </label>
                  <label>
                    <span>Display name</span>
                    <input
                      id="profile-name"
                      type="text"
                      placeholder="How should we greet you?"
                      autocomplete="name"
                    />
                  </label>
                  <label>
                    <span>Subscription ID (optional)</span>
                    <input
                      id="profile-subscription"
                      type="text"
                      placeholder="PayPal (I-...) or Stripe subscription ID"
                      autocomplete="off"
                      inputmode="text"
                      spellcheck="false"
                    />
                    <p class="helper-text">
                      Already have an active subscription? Paste your PayPal or Stripe subscription ID to
                      link it to this account.
                    </p>
                  </label>
                  <div class="cta-actions">
                    <button id="profile-save" type="submit" class="button-primary">
                      Save changes
                    </button>
                    <p id="profile-status" class="status-text"></p>
                  </div>
                </form>
              </article>

              <article id="password-panel" class="surface">
                <h2 class="section-title">Password &amp; security</h2>
                <p id="password-guidance" class="muted small password-guidance">
                  Update your dashboard password to keep your account secure.
                </p>
                <form id="password-form">
                  <label id="password-current-row">
                    <span>Current password</span>
                    <input
                      id="password-current"
                      type="password"
                      placeholder="••••••••"
                      autocomplete="current-password"
                    />
                  </label>
                  <label>
                    <span>New password</span>
                    <input
                      id="password-new"
                      type="password"
                      placeholder="Choose something memorable"
                      autocomplete="new-password"
                      required
                    />
                  </label>
                  <label>
                    <span>Confirm new password</span>
                    <input
                      id="password-confirm"
                      type="password"
                      placeholder="Repeat your new password"
                      autocomplete="new-password"
                    />
                  </label>
                  <div class="cta-actions">
                    <button id="password-save" type="submit" class="button-primary">
                      Update password
                    </button>
                    <p id="password-status" class="status-text"></p>
                  </div>
                </form>
              </article>

              <article class="surface">
                <h2 class="section-title">Your referral invites</h2>
                <p class="muted" id="invite-description">
                  Active subscribers can share one referral invite each month. We'll
                  highlight when the next referral unlocks. If you lost access,
                  regenerate your personal link here once the cooldown ends.
                </p>
                <form id="invite-form">
                  <label>
                    <span>Email for this referral invite</span>
                    <input
                      id="invite-email"
                      type="email"
                      placeholder="you@example.com"
                      autocomplete="email"
                      required
                    />
                  </label>
                  <label>
                    <span>Optional note for the recipient</span>
                    <input
                      id="invite-note"
                      type="text"
                      placeholder="Used for tracking referral invites"
                    />
                  </label>
                  <div class="cta-actions">
                    <button id="invite-submit" type="submit" class="button-primary">
                      Send referral invite
                    </button>
                    <p id="invite-status" class="status-text"></p>
                  </div>
                </form>
                <div id="invite-ready" class="invite-ready hidden">
                  <span class="badge success">Referral invite ready</span>
                  <a id="invite-link" class="invite-link" href="#" target="_blank" rel="noopener"></a>
                  <p id="invite-email-display" class="muted small"></p>
                  <p id="invite-created" class="muted small"></p>
                </div>
              </article>
            </section>

            <section
              id="dashboard-tabpanel-plex"
              class="dashboard-tabpanel"
              role="tabpanel"
              aria-labelledby="dashboard-tab-plex"
              data-dashboard-panel="plex"
              tabindex="-1"
              hidden
            >
              <article id="onboarding-panel" class="surface onboarding hidden">
                <h2 class="section-title">Unlock endless content in three steps</h2>
                <p class="muted">
                  You're only moments away from streaming everything you love.
                  Follow the guided path below to complete your setup.
                </p>
                <p class="status-text info">
                  <strong>
                    Before continuing, create or recover your Plex account at
                    <a href="https://www.plex.tv/sign-up/" target="_blank" rel="noopener"
                      >plex.tv</a
                    > so you can link it here—checkout stays disabled until Plex is ready.
                  </strong>
                </p>
                <div class="steps">
                  <div id="step-plex" class="step" data-state="current">
                    <div class="step-header">
                      <span class="step-number" data-step-number="1">1</span>
                      <div>
                        <h3 class="step-title">Authenticate with Plex</h3>
                        <p id="step-plex-note" class="muted small">
                          Use the button below to launch the Plex prompt and link
                          the account you use for streaming.
                        </p>
                      </div>
                    </div>
                    <p class="step-footnote muted small">
                      We rely on Plex to deliver the library—linking your account
                      keeps access seamless.
                    </p>
                    <div id="plex-link-controls" class="plex-link-controls">
                      <button id="plex-link-button" class="button-primary" type="button">
                        Link Plex account
                      </button>
                      <div
                        id="plex-link-pin"
                        class="plex-link-pin hidden"
                        aria-live="polite"
                      >
                        <span class="muted small">Use this PIN if Plex asks for it:</span>
                        <span id="plex-link-pin-code" class="plex-link-pin-code">----</span>
                        <span
                          id="plex-link-pin-expiry"
                          class="plex-link-pin-expiry"
                        ></span>
                      </div>
                      <p
                        id="plex-link-status"
                        class="status-text small"
                        aria-live="polite"
                      ></p>
                    </div>
                  </div>
                  <div id="step-subscription" class="step" data-state="upcoming">
                    <div class="step-header">
                      <span class="step-number" data-step-number="2">2</span>
                      <div>
                        <h3 class="step-title">Start your support subscription</h3>
                        <p id="step-subscription-note" class="muted small">
                          Once Plex is linked, choose PayPal or Stripe above to start
                          your membership.
                        </p>
                      </div>
                    </div>
                  </div>
                  <div id="step-invite" class="step" data-state="upcoming">
                    <div class="step-header">
                      <span class="step-number" data-step-number="3">3</span>
                      <div>
                        <h3 class="step-title">Share a referral invite</h3>
                        <p id="step-invite-note" class="muted small">
                          Send a referral invite each month to welcome someone new.
                          Lost your own library access? Regenerate your link here
                          when you’re eligible.
                        </p>
                      </div>
                    </div>
                  </div>
                </div>
              </article>
            </section>

            <section
              id="dashboard-tabpanel-support"
              class="dashboard-tabpanel"
              role="tabpanel"
              aria-labelledby="dashboard-tab-support"
              data-dashboard-panel="support"
              tabindex="-1"
              hidden
            >
              <article class="surface" id="support-panel">
                <h2 class="section-title">Need help?</h2>
                <p class="muted">
                  Reach out to the Plex Donate team for account help or streaming
                  questions. We’ll send updates to the email on your account.
                </p>
                <button id="support-toggle" type="button" class="button-link button-primary support-toggle">
                  Contact support
                </button>
                <div id="support-container" class="support-container hidden">
                  <div class="support-wrapper">
                    <form id="support-form" class="support-form">
                      <div class="support-actions">
                        <label for="support-name">Your name or display name</label>
                        <input id="support-name" name="name" type="text" autocomplete="name" />
                      </div>
                      <div class="support-actions">
                        <label for="support-subject">Subject</label>
                        <input id="support-subject" name="subject" type="text" required />
                      </div>
                      <div class="support-actions">
                        <label for="support-message">Message</label>
                        <textarea id="support-message" name="message" rows="4" required></textarea>
                      </div>
                      <button id="support-submit" type="submit" class="button-link button-primary">
                        Send support request
                      </button>
                      <p id="support-status" class="status-text small"></p>
                    </form>

                    <div class="support-threads" id="support-threads">
                      <div class="support-thread-list" id="support-thread-list"></div>
                      <p id="support-empty" class="support-empty hidden">
                        You haven't opened any support requests yet.
                      </p>
                      <div id="support-thread-detail" class="support-thread-detail hidden">
                        <div class="support-thread-meta">
                          <h3 id="support-thread-subject"></h3>
                          <span id="support-thread-status" class="support-status-pill support-status-open">Open</span>
                        </div>
                        <div id="support-messages" class="support-messages"></div>
                        <form id="support-reply-form" class="support-form">
                          <label for="support-reply-message">Reply</label>
                          <textarea id="support-reply-message" rows="3" required></textarea>
                          <button id="support-reply-submit" type="submit" class="button-link button-primary">
                            Send reply
                          </button>
                          <p id="support-reply-status" class="status-text small"></p>
                        </form>
                      </div>
                    </div>
                  </div>
                </div>
              </article>
            </section>

            <section
              id="dashboard-tabpanel-resources"
              class="dashboard-tabpanel"
              role="tabpanel"
              aria-labelledby="dashboard-tab-resources"
              data-dashboard-panel="resources"
              tabindex="-1"
              hidden
            >
              <article class="surface hidden" id="overseerr-section">
                <h2 class="section-title">Request new content through Overseerr</h2>
                <p class="muted">
                  Looking for a movie or show we don't have yet? Submit a request in
                  Overseerr so the server team can queue it up for you.
                </p>
                <ol class="request-list muted small">
                  <li>Sign in with your Plex account so requests stay linked.</li>
                  <li>
                    Search for the title you want and choose
                    <strong>Request</strong> to send it to the admins.
                  </li>
                  <li>
                    Visit the <strong>Activity</strong> tab to follow approvals and
                    downloads once they're underway.
                  </li>
                </ol>
                <a
                  class="button-link button-primary"
                  id="overseerr-link"
                  href="#"
                  aria-disabled="true"
                >
                  Open Overseerr
                </a>
              </article>

              <article class="surface">
                <h2 class="section-title">Streaming libraries</h2>
                <p class="muted">
                  Jump into your Plex library once your referral invite is accepted.
                  Save the link below for quick access.
                </p>
                <ul>
                  <li>
                    <a href="https://app.plex.tv/" target="_blank" rel="noopener"
                      >Launch Plex</a
                    >
                  </li>
                  <li class="muted small">
                    Need another referral? Active supporters can send a new invite
                    once the monthly cooldown resets—or regenerate their own link if
                    they’ve lost access.
                  </li>
                </ul>
              </article>
            </section>
          </div>
        </section>
      </main>
    </div>

    <script>
      const state = {
        data: null,
        inviteLimitReached: false,
        nextInviteAvailableAt: null,
        pendingPlexLink: null,
        announcement: null,
        support: {
          threads: [],
          activeThreadId: null,
          donorId: null,
          replyDrafts: {},
        },
      };
      let inviteCooldownTimer = null;
      let inviteCooldownTimerType = null;
      let plexLinkPollTimer = null;
      let plexLinkCountdownTimer = null;
      let plexLinkCountdownExpiryMs = null;
      let plexLinkAuthWindow = null;
      let plexLinkStatusSticky = false;
      let supportPanelOpen = false;
      let supportLoading = false;
      let supportThreadsRequest = null;

      const loadingPanel = document.getElementById('loading');
      const errorPanel = document.getElementById('error-panel');
      const app = document.getElementById('app');
      const loginPanel = document.getElementById('login-panel');
      const dashboardPanel = document.getElementById('dashboard-panel');
      const dashboardTablist = document.querySelector('[data-dashboard-tablist]');
      const dashboardTabButtons = dashboardTablist
        ? Array.from(
            dashboardTablist.querySelectorAll('[data-dashboard-tab]')
          )
        : [];
      const dashboardTabPanels = Array.from(
        document.querySelectorAll('[data-dashboard-panel]')
      );
      const DASHBOARD_TAB_DEFAULT = dashboardTabButtons.length > 0
        ? dashboardTabButtons[0].getAttribute('data-dashboard-tab') || 'account'
        : 'account';
      let activeDashboardTab = DASHBOARD_TAB_DEFAULT;

      const loginForm = document.getElementById('login-form');
      const loginButton = document.getElementById('login-button');
      const loginStatus = document.getElementById('login-status');
      const loginPassword = document.getElementById('login-password');
      const loginEmail = document.getElementById('login-email');
      const forgotPasswordLink = document.getElementById('forgot-password-link');
      const forgotPasswordHelp = document.getElementById('forgot-password-help');
      const defaultForgotPasswordLinkText = forgotPasswordLink
        ? forgotPasswordLink.textContent
        : 'Forgot your password?';
      const announcementBanner = document.getElementById('announcement-banner');
      const announcementChip = document.getElementById('announcement-chip');
      const announcementTitle = document.getElementById('announcement-title');
      const announcementBody = document.getElementById('announcement-body');
      const announcementCta = document.getElementById('announcement-cta');
      const announcementDismissButton = document.getElementById('announcement-dismiss');

      const logoutButton = document.getElementById('logout-button');
      const memberNameEl = document.getElementById('member-name');
      const memberEmailEl = document.getElementById('member-email');
      const memberStatusEl = document.getElementById('member-status');
      const memberPlanEl = document.getElementById('member-plan');
      const memberSubscriptionRow = document.getElementById('member-subscription-row');
      const memberSubscriptionId = document.getElementById('member-subscription-id');
      const memberLastPaymentRow = document.getElementById('member-last-payment-row');
      const memberLastPayment = document.getElementById('member-last-payment');
      const subscriptionCta = document.getElementById('subscription-cta');
      const subscriptionButton = document.getElementById('subscription-button');
      const stripeCheckoutDashboardButton = document.getElementById('stripe-checkout-dashboard-button');
      const subscriptionNote = document.getElementById('subscription-note');
      const stripeBillingPortalButton = document.getElementById('stripe-billing-portal-button');
      const stripePortalStatus = document.getElementById('stripe-portal-status');
      const trialButton = document.getElementById('trial-button');
      const trialStatus = document.getElementById('trial-status');
      const trialPanel = document.getElementById('trial-panel');
      const trialDaysRemainingValue = document.getElementById(
        'trial-days-remaining'
      );
      const trialDaysLabel = document.getElementById('trial-days-label');
      const trialEndDate = document.getElementById('trial-end-date');
      const trialCountdownDetail = document.getElementById(
        'trial-countdown-detail'
      );
      const memberStatusMessage = document.getElementById('member-status-message');
      const plexLinkButton = document.getElementById('plex-link-button');
      const plexLinkStatus = document.getElementById('plex-link-status');
      const plexLinkPin = document.getElementById('plex-link-pin');
      const plexLinkPinCode = document.getElementById('plex-link-pin-code');
      const plexLinkPinExpiry = document.getElementById('plex-link-pin-expiry');
      const changePasswordButton = document.getElementById('change-password-button');
      const onboardingPanel = document.getElementById('onboarding-panel');
      const stepSubscription = document.getElementById('step-subscription');
      const stepPlex = document.getElementById('step-plex');
      const stepInvite = document.getElementById('step-invite');
      const stepSubscriptionNote = document.getElementById('step-subscription-note');
      const stepPlexNote = document.getElementById('step-plex-note');
      const stepInviteNote = document.getElementById('step-invite-note');
      const overseerrSection = document.getElementById('overseerr-section');
      const overseerrLink = document.getElementById('overseerr-link');
      const supportToggle = document.getElementById('support-toggle');
      const supportContainer = document.getElementById('support-container');
      const supportForm = document.getElementById('support-form');
      const supportNameInput = document.getElementById('support-name');
      const supportSubjectInput = document.getElementById('support-subject');
      const supportMessageInput = document.getElementById('support-message');
      const supportSubmit = document.getElementById('support-submit');
      const supportStatus = document.getElementById('support-status');
      const supportThreads = document.getElementById('support-threads');
      const supportThreadList = document.getElementById('support-thread-list');
      const supportThreadDetail = document.getElementById('support-thread-detail');
      const supportThreadSubject = document.getElementById('support-thread-subject');
      const supportThreadStatus = document.getElementById('support-thread-status');
      const supportMessages = document.getElementById('support-messages');
      const supportEmpty = document.getElementById('support-empty');
      const supportReplyForm = document.getElementById('support-reply-form');
      const supportReplyMessage = document.getElementById('support-reply-message');
      const supportReplyStatus = document.getElementById('support-reply-status');
      const supportReplySubmit = document.getElementById('support-reply-submit');
      const defaultSubscriptionButtonLabel = subscriptionButton
        ? subscriptionButton.textContent
        : 'Start subscription';
      if (subscriptionButton) {
        subscriptionButton.disabled = true;
        subscriptionButton.dataset.available = 'false';
      }
      const defaultTrialButtonLabel = trialButton
        ? trialButton.textContent
        : 'Start 7-day trial';
      if (trialButton) {
        trialButton.disabled = true;
        trialButton.dataset.available = 'false';
      }

      if (supportReplyMessage) {
        supportReplyMessage.addEventListener('input', () => {
          const activeThreadId = state.support.activeThreadId;
          if (!activeThreadId) {
            return;
          }
          if (!state.support.replyDrafts) {
            state.support.replyDrafts = {};
          }
          const value = supportReplyMessage.value;
          if (!value) {
            delete state.support.replyDrafts[activeThreadId];
          } else {
            state.support.replyDrafts[activeThreadId] = value;
          }
        });
      }

      const SESSION_TOKEN_QUERY_PARAM = 'session';
      const VERIFICATION_TOKEN_QUERY_PARAM = 'token';
      let sessionToken = null;
      let initialVerificationToken = null;
      let verificationInFlight = false;

      const ANNOUNCEMENT_TONE_LABELS = {
        info: 'Information',
        success: 'Success',
        warning: 'Warning',
        danger: 'Alert',
        neutral: 'Update',
      };
      const ANNOUNCEMENT_DISMISSAL_KEY = 'plexDonateAnnouncementDismissed';
      let dismissedAnnouncementFingerprint = null;

      try {
        dismissedAnnouncementFingerprint =
          window.localStorage.getItem(ANNOUNCEMENT_DISMISSAL_KEY) || null;
      } catch (err) {
        dismissedAnnouncementFingerprint = null;
      }

      function normalizeSessionToken(token) {
        if (typeof token !== 'string') {
          return null;
        }
        const trimmed = token.trim();
        return trimmed ? trimmed : null;
      }

      function applySessionTokenToUrl(token) {
        try {
          const url = new URL(window.location.href);
          if (token) {
            url.searchParams.set(SESSION_TOKEN_QUERY_PARAM, token);
          } else {
            url.searchParams.delete(SESSION_TOKEN_QUERY_PARAM);
          }
          const nextUrl = `${url.pathname}${url.search}${url.hash}`;
          window.history.replaceState({}, '', nextUrl);
        } catch (err) {
          // Ignore URL manipulation errors.
        }
      }

      function setSessionToken(token) {
        const normalized = normalizeSessionToken(token);
        if (normalized === sessionToken) {
          return;
        }
        sessionToken = normalized;
        applySessionTokenToUrl(sessionToken);
      }

      (function initializeSessionTokenFromUrl() {
        try {
          const url = new URL(window.location.href);
          const existing = url.searchParams.get(SESSION_TOKEN_QUERY_PARAM);
          if (existing) {
            setSessionToken(existing);
          }
        } catch (err) {
          sessionToken = null;
        }
      })();

      function extractVerificationTokenFromUrl() {
        try {
          const url = new URL(window.location.href);
          const tokenValue = url.searchParams.get(VERIFICATION_TOKEN_QUERY_PARAM);
          if (!tokenValue) {
            return null;
          }
          url.searchParams.delete(VERIFICATION_TOKEN_QUERY_PARAM);
          if (/\/verify\/?$/i.test(url.pathname)) {
            const withoutSegment = url.pathname.replace(/\/verify\/?$/i, '/');
            if (withoutSegment.length > 1 && withoutSegment.endsWith('/')) {
              url.pathname = withoutSegment.slice(0, -1);
            } else {
              url.pathname = withoutSegment || '/';
            }
          }
          const nextUrl = `${url.pathname}${url.search}${url.hash}`;
          window.history.replaceState({}, '', nextUrl);
          return tokenValue;
        } catch (err) {
          return null;
        }
      }

      initialVerificationToken = extractVerificationTokenFromUrl();

      function withSessionToken(path) {
        if (!sessionToken) {
          return path;
        }
        try {
          const url = new URL(path, window.location.origin);
          url.searchParams.set(SESSION_TOKEN_QUERY_PARAM, sessionToken);
          return url.toString();
        } catch (err) {
          return path;
        }
      }

      function updateSessionTokenFromResponse(data) {
        if (!data || typeof data !== 'object') {
          return;
        }
        if (Object.prototype.hasOwnProperty.call(data, 'sessionToken')) {
          setSessionToken(data.sessionToken);
        }
      }

      function normalizeAnnouncementPayload(payload) {
        if (!payload || typeof payload !== 'object') {
          return null;
        }
        const toneRaw = typeof payload.tone === 'string'
          ? payload.tone.trim().toLowerCase()
          : '';
        const tone = Object.prototype.hasOwnProperty.call(
          ANNOUNCEMENT_TONE_LABELS,
          toneRaw
        )
          ? toneRaw
          : 'info';
        const title = typeof payload.title === 'string' ? payload.title.trim() : '';
        const body = typeof payload.body === 'string' ? payload.body.trim() : '';
        const dismissible = Boolean(payload.dismissible);
        const enabled = Boolean(payload.enabled);
        let cta = null;
        if (payload.cta && typeof payload.cta === 'object') {
          const label =
            typeof payload.cta.label === 'string' ? payload.cta.label.trim() : '';
          const url = typeof payload.cta.url === 'string' ? payload.cta.url.trim() : '';
          const openInNewTab = Boolean(payload.cta.openInNewTab);
          if (label && url) {
            cta = { label, url, openInNewTab };
          }
        }
        return { enabled, title, body, tone, dismissible, cta };
      }

      function buildAnnouncementFingerprint(announcement) {
        if (!announcement) {
          return '';
        }
        return JSON.stringify({
          tone: announcement.tone,
          title: announcement.title,
          body: announcement.body,
          dismissible: announcement.dismissible,
          ctaLabel: announcement.cta ? announcement.cta.label : '',
          ctaUrl: announcement.cta ? announcement.cta.url : '',
        });
      }

      function isAnnouncementDismissed(announcement) {
        if (!announcement || !announcement.dismissible) {
          return false;
        }
        const fingerprint = buildAnnouncementFingerprint(announcement);
        return fingerprint && fingerprint === dismissedAnnouncementFingerprint;
      }

      function rememberAnnouncementDismissal(announcement) {
        if (!announcement || !announcement.dismissible) {
          return;
        }
        const fingerprint = buildAnnouncementFingerprint(announcement);
        if (!fingerprint) {
          return;
        }
        dismissedAnnouncementFingerprint = fingerprint;
        try {
          window.localStorage.setItem(ANNOUNCEMENT_DISMISSAL_KEY, fingerprint);
        } catch (err) {
          // ignore storage errors
        }
      }

      function setElementVisibility(element, visible) {
        if (!element) {
          return;
        }
        if (visible) {
          element.classList.remove('hidden');
          element.removeAttribute('hidden');
        } else {
          element.classList.add('hidden');
          element.setAttribute('hidden', '');
        }
      }

      function isValidDashboardTab(value) {
        if (!value) {
          return false;
        }
        return dashboardTabPanels.some((panel) => {
          const panelName =
            (panel.dataset && panel.dataset.dashboardPanel) ||
            panel.getAttribute('data-dashboard-panel');
          return panelName === value;
        });
      }

      function applyActiveDashboardTab() {
        if (dashboardTabButtons.length === 0 || dashboardTabPanels.length === 0) {
          return;
        }

        dashboardTabButtons.forEach((button) => {
          const tabName = button.getAttribute('data-dashboard-tab');
          const isActive = tabName === activeDashboardTab;
          button.setAttribute('aria-selected', isActive ? 'true' : 'false');
          button.setAttribute('tabindex', isActive ? '0' : '-1');
          button.classList.toggle('is-active', isActive);
        });

        dashboardTabPanels.forEach((panel) => {
          const panelName =
            (panel.dataset && panel.dataset.dashboardPanel) ||
            panel.getAttribute('data-dashboard-panel');
          const isActive = panelName === activeDashboardTab;
          if (isActive) {
            panel.removeAttribute('hidden');
            panel.setAttribute('tabindex', '0');
          } else {
            panel.setAttribute('hidden', '');
            panel.setAttribute('tabindex', '-1');
          }
        });
      }

      function setActiveDashboardTab(next, options = {}) {
        if (dashboardTabButtons.length === 0 || dashboardTabPanels.length === 0) {
          return;
        }
        const { force = false } = options;
        const normalized = isValidDashboardTab(next)
          ? next
          : DASHBOARD_TAB_DEFAULT;
        if (!force && normalized === activeDashboardTab) {
          return;
        }
        activeDashboardTab = normalized;
        applyActiveDashboardTab();
      }

      if (dashboardTabButtons.length > 0) {
        const focusDashboardTabByIndex = (index) => {
          const button = dashboardTabButtons[index];
          if (!button) {
            return;
          }
          const target = button.getAttribute('data-dashboard-tab');
          setActiveDashboardTab(target);
          try {
            button.focus();
          } catch (err) {
            // ignore focus errors
          }
        };

        dashboardTabButtons.forEach((button) => {
          button.addEventListener('click', () => {
            const target = button.getAttribute('data-dashboard-tab');
            setActiveDashboardTab(target);
          });
        });

        if (dashboardTablist) {
          dashboardTablist.addEventListener('keydown', (event) => {
            const { key } = event;
            if (!['ArrowLeft', 'ArrowRight', 'Home', 'End'].includes(key)) {
              return;
            }
            event.preventDefault();
            const activeElement = document.activeElement;
            let currentIndex = dashboardTabButtons.indexOf(activeElement);
            if (currentIndex === -1) {
              currentIndex = dashboardTabButtons.findIndex((button) =>
                button.getAttribute('data-dashboard-tab') === activeDashboardTab
              );
            }
            if (key === 'Home') {
              focusDashboardTabByIndex(0);
              return;
            }
            if (key === 'End') {
              focusDashboardTabByIndex(dashboardTabButtons.length - 1);
              return;
            }
            if (key === 'ArrowLeft') {
              const previousIndex =
                currentIndex <= 0
                  ? dashboardTabButtons.length - 1
                  : currentIndex - 1;
              focusDashboardTabByIndex(previousIndex);
            } else if (key === 'ArrowRight') {
              const nextIndex = (currentIndex + 1) % dashboardTabButtons.length;
              focusDashboardTabByIndex(nextIndex);
            }
          });
        }

        setActiveDashboardTab(activeDashboardTab, { force: true });
      }

      function resetAnnouncementCta() {
        if (!announcementCta) {
          return;
        }
        announcementCta.classList.add('hidden');
        announcementCta.textContent = '';
        announcementCta.removeAttribute('href');
        announcementCta.removeAttribute('target');
        announcementCta.removeAttribute('rel');
      }

      function renderAnnouncementBanner(payload) {
        if (!announcementBanner) {
          state.announcement = null;
          return;
        }

        const normalized = normalizeAnnouncementPayload(payload);
        state.announcement = normalized;

        if (
          !normalized ||
          !normalized.enabled ||
          (!normalized.title && !normalized.body) ||
          isAnnouncementDismissed(normalized)
        ) {
          announcementBanner.classList.add('hidden');
          announcementBanner.dataset.tone = 'info';
          if (announcementTitle) {
            announcementTitle.textContent = '';
          }
          if (announcementBody) {
            announcementBody.textContent = '';
            announcementBody.classList.add('hidden');
          }
          resetAnnouncementCta();
          if (announcementDismissButton) {
            announcementDismissButton.classList.add('hidden');
            announcementDismissButton.setAttribute('aria-hidden', 'true');
          }
          return;
        }

        announcementBanner.classList.remove('hidden');
        announcementBanner.dataset.tone = normalized.tone;

        if (announcementChip) {
          announcementChip.textContent =
            ANNOUNCEMENT_TONE_LABELS[normalized.tone] || 'Information';
        }

        if (announcementTitle) {
          announcementTitle.textContent = normalized.title || 'Notice';
        }

        if (announcementBody) {
          if (normalized.body) {
            announcementBody.textContent = normalized.body;
            announcementBody.classList.remove('hidden');
          } else {
            announcementBody.textContent = '';
            announcementBody.classList.add('hidden');
          }
        }

        if (normalized.cta && announcementCta) {
          announcementCta.classList.remove('hidden');
          announcementCta.textContent = normalized.cta.label;
          announcementCta.href = normalized.cta.url;
          if (normalized.cta.openInNewTab) {
            announcementCta.target = '_blank';
            announcementCta.rel = 'noopener';
          } else {
            announcementCta.removeAttribute('target');
            announcementCta.removeAttribute('rel');
          }
        } else {
          resetAnnouncementCta();
        }

        if (announcementDismissButton) {
          if (normalized.dismissible) {
            announcementDismissButton.classList.remove('hidden');
            announcementDismissButton.removeAttribute('aria-hidden');
          } else {
            announcementDismissButton.classList.add('hidden');
            announcementDismissButton.setAttribute('aria-hidden', 'true');
          }
        }
      }

      function renderOverseerrIntegration(integrations) {
        if (!overseerrSection) {
          return;
        }

        const payload =
          integrations && typeof integrations === 'object'
            ? integrations.overseerr || null
            : null;
        const rawUrl =
          payload && payload.url ? String(payload.url).trim() : '';

        if (rawUrl) {
          overseerrSection.classList.remove('hidden');
          if (overseerrLink) {
            overseerrLink.href = rawUrl;
            overseerrLink.removeAttribute('aria-disabled');
            overseerrLink.target = '_blank';
            overseerrLink.rel = 'noopener noreferrer';
          }
          return;
        }

        overseerrSection.classList.add('hidden');
        if (overseerrLink) {
          overseerrLink.href = '#';
          overseerrLink.setAttribute('aria-disabled', 'true');
          overseerrLink.removeAttribute('target');
          overseerrLink.removeAttribute('rel');
        }
      }

      if (announcementDismissButton) {
        announcementDismissButton.addEventListener('click', () => {
          if (!state.announcement || !state.announcement.dismissible) {
            return;
          }
          rememberAnnouncementDismissal(state.announcement);
          renderAnnouncementBanner(null);
        });
      }

      function buildSessionRequest(path, options = {}) {
        const requestUrl = withSessionToken(path);
        const requestOptions = { ...options };
        requestOptions.headers = options && options.headers
          ? { ...options.headers }
          : {};
        if (sessionToken) {
          requestOptions.headers['X-Session-Token'] = sessionToken;
        }
        return { requestUrl, requestOptions };
      }

      async function sessionFetch(path, options = {}) {
        const { requestUrl, requestOptions } = buildSessionRequest(path, options);
        return fetch(requestUrl, requestOptions);
      }

      async function submitVerificationToken(token) {
        if (!token || verificationInFlight) {
          return;
        }
        verificationInFlight = true;
        try {
          showLoading();
          const response = await fetch('/api/customer/verify', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token }),
          });
          let payload = {};
          try {
            payload = await response.json();
          } catch (err) {
            payload = {};
          }
          updateSessionTokenFromResponse(payload);
          if (!response.ok) {
            const errorMessage =
              (payload && payload.error) ||
              'Failed to verify email. Try again shortly.';
            throw new Error(errorMessage);
          }
          renderDashboard(payload);
          if (memberStatusMessage) {
            setStatusText(
              memberStatusMessage,
              'Email verified successfully! Welcome back to the dashboard.',
              'success'
            );
            memberStatusMessage.classList.add('small');
          }
        } catch (err) {
          const message = err && err.message
            ? err.message
            : 'Failed to verify email. Try again shortly.';
          if (state.data && state.data.authenticated) {
            if (memberStatusMessage) {
              setStatusText(memberStatusMessage, message, 'error');
              memberStatusMessage.classList.add('small');
            }
          } else {
            renderDashboard({ authenticated: false });
            setStatusText(loginStatus, message, 'error');
          }
          fetchSession({ silent: true });
        } finally {
          verificationInFlight = false;
          initialVerificationToken = null;
        }
      }

      const profileForm = document.getElementById('profile-form');
      const profileEmail = document.getElementById('profile-email');
      const profileName = document.getElementById('profile-name');
      const profileSubscription = document.getElementById('profile-subscription');
      const profileStatus = document.getElementById('profile-status');
      const profileSave = document.getElementById('profile-save');
      const passwordForm = document.getElementById('password-form');
      const passwordCurrentRow = document.getElementById('password-current-row');
      const passwordCurrent = document.getElementById('password-current');
      const passwordNew = document.getElementById('password-new');
      const passwordConfirm = document.getElementById('password-confirm');
      const passwordStatus = document.getElementById('password-status');
      const passwordSave = document.getElementById('password-save');
      const passwordGuidance = document.getElementById('password-guidance');
      const passwordPanel = document.getElementById('password-panel');

      const inviteForm = document.getElementById('invite-form');
      const inviteEmail = document.getElementById('invite-email');
      const inviteNote = document.getElementById('invite-note');
      const inviteStatus = document.getElementById('invite-status');
      const inviteSubmit = document.getElementById('invite-submit');
      const inviteReady = document.getElementById('invite-ready');
      const inviteLinkEl = document.getElementById('invite-link');
      const inviteEmailDisplay = document.getElementById('invite-email-display');
      const inviteCreated = document.getElementById('invite-created');
      const inviteDescription = document.getElementById('invite-description');

      function showLoading() {
        loadingPanel.classList.remove('hidden');
        errorPanel.classList.add('hidden');
        app.classList.add('hidden');
      }

      function showError(message) {
        loadingPanel.classList.add('hidden');
        errorPanel.textContent = message || 'Something went wrong.';
        errorPanel.classList.remove('hidden');
        app.classList.add('hidden');
      }

      function showApp() {
        loadingPanel.classList.add('hidden');
        errorPanel.classList.add('hidden');
        app.classList.remove('hidden');
      }

      function formatPrice(amount, currency) {
        if (!Number.isFinite(amount) || amount <= 0) {
          return '';
        }
        try {
          return new Intl.NumberFormat(undefined, {
            style: 'currency',
            currency: currency || 'USD',
            minimumFractionDigits: 2,
          }).format(amount);
        } catch (err) {
          return `${amount.toFixed(2)} ${currency || ''}`.trim();
        }
      }

      function formatDate(value) {
        if (!value) {
          return '';
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return value;
        }
        return date.toLocaleString();
      }

      function parseDate(value) {
        if (!value) {
          return null;
        }
        if (value instanceof Date) {
          return Number.isNaN(value.getTime()) ? null : value;
        }
        const parsed = new Date(value);
        return Number.isNaN(parsed.getTime()) ? null : parsed;
      }

      function formatDateTime(value) {
        const date = parseDate(value);
        if (!date) {
          return '';
        }
        try {
          return new Intl.DateTimeFormat(undefined, {
            dateStyle: 'medium',
            timeStyle: 'short',
          }).format(date);
        } catch (err) {
          return date.toLocaleString();
        }
      }

      function getPlexCountdownLabel(expiresAt) {
        const date = parseDate(expiresAt);
        if (!date) {
          return '';
        }
        const diff = date.getTime() - Date.now();
        if (diff <= 0) {
          return '';
        }
        const minutes = Math.max(0, Math.floor(diff / 60000));
        const seconds = Math.max(0, Math.floor((diff % 60000) / 1000));
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
      }

      function getTrialCountdownLabel(expiresAt) {
        const date = parseDate(expiresAt);
        if (!date) {
          return '';
        }
        const diff = date.getTime() - Date.now();
        if (diff <= 0) {
          return '';
        }
        const totalMinutes = Math.max(0, Math.floor(diff / 60000));
        const minutesPerDay = 24 * 60;
        const minutesPerHour = 60;
        const days = Math.floor(totalMinutes / minutesPerDay);
        const hours = Math.floor((totalMinutes % minutesPerDay) / minutesPerHour);
        const minutes = totalMinutes % minutesPerHour;
        const parts = [];
        if (days > 0) {
          parts.push(`${days} day${days === 1 ? '' : 's'}`);
        }
        if (hours > 0) {
          parts.push(`${hours} hour${hours === 1 ? '' : 's'}`);
        }
        if (parts.length < 2 && minutes > 0) {
          parts.push(`${minutes} minute${minutes === 1 ? '' : 's'}`);
        }
        if (parts.length === 0) {
          return 'less than a minute';
        }
        if (parts.length === 1) {
          return parts[0];
        }
        return `${parts[0]} and ${parts[1]}`;
      }

      function getTrialDaysRemaining(expiresAt) {
        const date = parseDate(expiresAt);
        if (!date) {
          return null;
        }
        const diff = date.getTime() - Date.now();
        if (diff <= 0) {
          return 0;
        }
        const MS_PER_DAY = 24 * 60 * 60 * 1000;
        return Math.floor(diff / MS_PER_DAY);
      }

      function clearInviteCooldownTimer() {
        if (!inviteCooldownTimer) {
          return;
        }
        if (inviteCooldownTimerType === 'interval') {
          window.clearInterval(inviteCooldownTimer);
        } else {
          window.clearTimeout(inviteCooldownTimer);
        }
        inviteCooldownTimer = null;
        inviteCooldownTimerType = null;
      }

      function scheduleInviteCooldownRefresh(nextAvailableAt) {
        clearInviteCooldownTimer();
        const nextDate = parseDate(nextAvailableAt);
        state.nextInviteAvailableAt = nextDate
          ? nextDate.toISOString()
          : null;
        if (!nextDate) {
          return;
        }
        const delay = nextDate.getTime() - Date.now();
        if (delay <= 0) {
          fetchSession({ silent: true });
          return;
        }
        const MAX_TIMEOUT = 2_147_483_647;
        if (delay > MAX_TIMEOUT) {
          inviteCooldownTimer = window.setInterval(() => {
            if (Date.now() >= nextDate.getTime()) {
              clearInviteCooldownTimer();
              fetchSession({ silent: true });
            }
          }, 60 * 60 * 1000);
          inviteCooldownTimerType = 'interval';
        } else {
          inviteCooldownTimer = window.setTimeout(() => {
            clearInviteCooldownTimer();
            fetchSession({ silent: true });
          }, delay);
          inviteCooldownTimerType = 'timeout';
        }
      }

      function setStatusText(el, message, statusClass) {
        if (!el) return;
        el.textContent = message || '';
        el.className = 'status-text';
        if (statusClass) {
          el.classList.add(statusClass);
        }
      }

      function formatSupportTimestamp(value) {
        if (!value) {
          return '';
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return '';
        }
        return date.toLocaleString();
      }

      function getSupportThreadLocal(id) {
        const threads = Array.isArray(state.support.threads)
          ? state.support.threads
          : [];
        return threads.find(
          (thread) => thread && thread.request && thread.request.id === id
        );
      }

      function renderSupportThreadDetail() {
        if (!supportThreadDetail || !supportThreadSubject || !supportMessages) {
          return;
        }
        const thread = getSupportThreadLocal(state.support.activeThreadId);
        if (!thread) {
          supportThreadDetail.classList.add('hidden');
          return;
        }
        supportThreadDetail.classList.remove('hidden');
        supportThreadSubject.textContent =
          thread.request.subject || `Request #${thread.request.id}`;
        const isResolved = Boolean(thread.request.resolved);
        supportThreadStatus.textContent = isResolved ? 'Resolved' : 'Open';
        supportThreadStatus.classList.toggle('support-status-open', !isResolved);
        supportThreadStatus.classList.toggle('support-status-resolved', isResolved);
        supportMessages.innerHTML = '';
        const messages = Array.isArray(thread.messages) ? thread.messages : [];
        if (messages.length === 0) {
          const emptyMessage = document.createElement('p');
          emptyMessage.className = 'support-empty';
          emptyMessage.textContent = 'No messages yet.';
          supportMessages.appendChild(emptyMessage);
        } else {
          messages.forEach((message) => {
            const messageEl = document.createElement('div');
            messageEl.className = 'support-message';
            messageEl.dataset.author = message.authorRole || 'donor';

            const authorEl = document.createElement('div');
            authorEl.className = 'support-message-author';
            authorEl.textContent =
              message.authorName ||
              (message.authorRole === 'admin' ? 'Admin' : 'You');

            const metaEl = document.createElement('div');
            metaEl.className = 'support-message-meta';
            metaEl.textContent = formatSupportTimestamp(message.createdAt);

            const bodyEl = document.createElement('div');
            bodyEl.textContent = message.body || '';

            messageEl.append(authorEl, metaEl, bodyEl);
            supportMessages.appendChild(messageEl);
          });
          supportMessages.scrollTop = supportMessages.scrollHeight;
        }

        if (supportReplyMessage) {
          const drafts = state.support.replyDrafts || {};
          const draftValue = drafts[thread.request.id] || '';
          supportReplyMessage.value = draftValue;
        }
        if (supportReplyStatus) {
          setStatusText(supportReplyStatus, '');
        }
      }

      function renderSupportThreads() {
        if (!supportThreadList || !supportThreads) {
          return;
        }
        const threads = Array.isArray(state.support.threads)
          ? state.support.threads
          : [];
        supportThreadList.innerHTML = '';
        if (threads.length === 0) {
          if (supportEmpty) {
            supportEmpty.classList.remove('hidden');
          }
          supportThreadDetail && supportThreadDetail.classList.add('hidden');
          return;
        }

        if (supportEmpty) {
          supportEmpty.classList.add('hidden');
        }

        if (!threads.some((thread) => thread.request.id === state.support.activeThreadId)) {
          state.support.activeThreadId = threads[0].request.id;
        }

        threads.forEach((thread) => {
          if (!thread || !thread.request) {
            return;
          }
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'support-thread-button';
          const isActive = thread.request.id === state.support.activeThreadId;
          button.setAttribute('aria-current', isActive ? 'true' : 'false');

          const titleEl = document.createElement('h3');
          titleEl.textContent = thread.request.subject || `Request #${thread.request.id}`;

          const statusEl = document.createElement('span');
          const resolved = Boolean(thread.request.resolved);
          statusEl.className = `support-status-pill ${resolved ? 'support-status-resolved' : 'support-status-open'}`;
          statusEl.textContent = resolved ? 'Resolved' : 'Open';

          button.append(titleEl, statusEl);
          button.addEventListener('click', () => {
            state.support.activeThreadId = thread.request.id;
            renderSupportThreads();
          });

          supportThreadList.appendChild(button);
        });

        renderSupportThreadDetail();
      }

      async function loadSupportThreads(options = {}) {
        while (supportThreadsRequest) {
          try {
            await supportThreadsRequest;
          } catch (err) {
            // Previous invocation already handled the error display.
          }
        }

        const request = (async () => {
          supportLoading = true;
          try {
            const response = await sessionFetch('/api/customer/support');
            const payload = await response.json();
            updateSessionTokenFromResponse(payload);
            if (!response.ok) {
              throw new Error(
                payload && payload.error
                  ? payload.error
                  : 'Failed to load support requests'
              );
            }
            const threads = Array.isArray(payload.threads) ? payload.threads : [];
            state.support.threads = threads;
            if (threads.length === 0) {
              state.support.activeThreadId = null;
            }
            renderSupportThreads();
            return payload;
          } catch (err) {
            if (!options.silent && supportStatus) {
              setStatusText(
                supportStatus,
                err.message || 'Failed to load support requests.',
                'error'
              );
            }
            return null;
          } finally {
            supportLoading = false;
          }
        })();

        supportThreadsRequest = request.finally(() => {
          supportThreadsRequest = null;
        });

        return supportThreadsRequest;
      }

      async function setSupportPanelOpen(open) {
        if (!supportContainer || !supportToggle) {
          return;
        }
        supportPanelOpen = Boolean(open);
        if (supportPanelOpen) {
          supportContainer.classList.remove('hidden');
          supportToggle.textContent = 'Hide support';
          await loadSupportThreads({ silent: true });
        } else {
          supportContainer.classList.add('hidden');
          supportToggle.textContent = 'Contact support';
        }
      }

      function clearPlexLinkPollTimer() {
        if (!plexLinkPollTimer) {
          return;
        }
        window.clearTimeout(plexLinkPollTimer);
        plexLinkPollTimer = null;
      }

      function schedulePlexLinkStatusPoll(intervalMs) {
        if (!state.pendingPlexLink) {
          clearPlexLinkPollTimer();
          return;
        }
        const normalized = Number(intervalMs ?? state.pendingPlexLink.pollIntervalMs);
        const delay = Number.isFinite(normalized) && normalized > 0 ? normalized : 5000;
        clearPlexLinkPollTimer();
        plexLinkPollTimer = window.setTimeout(() => {
          plexLinkPollTimer = null;
          pollPlexLinkStatus();
        }, delay);
      }

      function clearPlexLinkCountdownTimer({ resetText = true } = {}) {
        if (plexLinkCountdownTimer) {
          window.clearInterval(plexLinkCountdownTimer);
          plexLinkCountdownTimer = null;
        }
        plexLinkCountdownExpiryMs = null;
        if (resetText && plexLinkPinExpiry) {
          plexLinkPinExpiry.textContent = '';
        }
      }

      function updatePlexLinkCountdownDisplay() {
        if (!plexLinkPinExpiry || !Number.isFinite(plexLinkCountdownExpiryMs)) {
          if (plexLinkPinExpiry) {
            plexLinkPinExpiry.textContent = '';
          }
          return '';
        }
        const diff = plexLinkCountdownExpiryMs - Date.now();
        if (diff <= 0) {
          plexLinkPinExpiry.textContent = 'PIN expired';
          return '';
        }
        const minutes = Math.max(0, Math.floor(diff / 60000));
        const seconds = Math.max(0, Math.floor((diff % 60000) / 1000));
        const formatted = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        plexLinkPinExpiry.textContent = `Expires in ${formatted}`;
        return formatted;
      }

      function startPlexLinkCountdown(expiresAt) {
        const date = parseDate(expiresAt);
        if (!date) {
          clearPlexLinkCountdownTimer();
          return '';
        }
        const targetMs = date.getTime();
        if (plexLinkCountdownTimer && plexLinkCountdownExpiryMs === targetMs) {
          return updatePlexLinkCountdownDisplay();
        }
        clearPlexLinkCountdownTimer();
        plexLinkCountdownExpiryMs = targetMs;
        const initial = updatePlexLinkCountdownDisplay();
        if (!initial) {
          return '';
        }
        plexLinkCountdownTimer = window.setInterval(() => {
          const next = updatePlexLinkCountdownDisplay();
          if (!next) {
            clearPlexLinkCountdownTimer({ resetText: false });
          }
        }, 1000);
        return initial;
      }

      function closePlexAuthWindow() {
        if (plexLinkAuthWindow && !plexLinkAuthWindow.closed) {
          try {
            plexLinkAuthWindow.close();
          } catch (err) {
            // Ignore window close errors.
          }
        }
        plexLinkAuthWindow = null;
      }

      function setPlexLinkStatus(message, tone, { sticky = false, force = false } = {}) {
        if (!force && plexLinkStatusSticky && !sticky) {
          return;
        }
        plexLinkStatusSticky = sticky;
        if (!plexLinkStatus) {
          return;
        }
        setStatusText(plexLinkStatus, message, tone || null);
        plexLinkStatus.classList.add('small');
      }

      function clearPlexLinkStatus({ force = false } = {}) {
        if (!force && plexLinkStatusSticky) {
          return;
        }
        plexLinkStatusSticky = false;
        if (!plexLinkStatus) {
          return;
        }
        setStatusText(plexLinkStatus, '', null);
        plexLinkStatus.classList.add('small');
      }

      async function pollPlexLinkStatus() {
        if (!state.pendingPlexLink) {
          clearPlexLinkPollTimer();
          return;
        }
        let response;
        try {
          response = await sessionFetch('/api/customer/plex/link/status');
        } catch (err) {
          setPlexLinkStatus('Unable to reach Plex right now. Retrying…', 'error', {
            force: true,
          });
          schedulePlexLinkStatusPoll(state.pendingPlexLink.pollIntervalMs);
          return;
        }
        let payload = {};
        try {
          payload = await response.json();
        } catch (err) {
          payload = {};
        }
        updateSessionTokenFromResponse(payload);
        if (!response.ok) {
          const payloadData = payload && payload.payload ? payload.payload : null;
          if (payloadData) {
            renderDashboard(payloadData);
          } else {
            applyPlexLinkState(null, null);
          }
          const plexErrorMessage = payload && payload.error
            ? `${payload.error} Try starting the link again.`
            : 'Failed to verify Plex authentication. Try starting the link again.';
          setPlexLinkStatus(plexErrorMessage, 'error', { sticky: true, force: true });
          clearPlexLinkPollTimer();
          clearPlexLinkCountdownTimer({ resetText: false });
          closePlexAuthWindow();
          return;
        }
        renderDashboard(payload);
      }

      function applyPlexLinkState(donor, plexLink) {
        const plexLinked = Boolean(donor && donor.plexLinked);
        const pending = plexLink && plexLink.pending ? plexLink : null;

        if (pending) {
          state.pendingPlexLink = {
            code: pending.code || '',
            authUrl: pending.authUrl || '',
            expiresAt: pending.expiresAt || null,
            pollIntervalMs: Number(pending.pollIntervalMs) || null,
          };
        } else {
          state.pendingPlexLink = null;
        }

        if (plexLinkButton) {
          if (plexLinked || pending) {
            plexLinkButton.classList.add('hidden');
            plexLinkButton.disabled = true;
          } else {
            plexLinkButton.classList.remove('hidden');
            plexLinkButton.disabled = false;
          }
        }

        if (pending) {
          if (plexLinkPin) {
            plexLinkPin.classList.remove('hidden');
          }
          if (plexLinkPinCode) {
            plexLinkPinCode.textContent = state.pendingPlexLink.code || '----';
          }
          const countdown = startPlexLinkCountdown(state.pendingPlexLink.expiresAt);
          const baseMessage =
            'Waiting for Plex to confirm your account. Complete the Plex prompt in the new tab.';
          const message = countdown
            ? `${baseMessage} PIN expires in ${countdown}.`
            : baseMessage;
          setPlexLinkStatus(message, 'info', { force: true });
          schedulePlexLinkStatusPoll(state.pendingPlexLink.pollIntervalMs);
        } else {
          clearPlexLinkCountdownTimer();
          clearPlexLinkPollTimer();
          if (plexLinkPin) {
            plexLinkPin.classList.add('hidden');
          }
          if (plexLinkPinCode) {
            plexLinkPinCode.textContent = '----';
          }
          if (plexLinkPinExpiry) {
            plexLinkPinExpiry.textContent = '';
          }
          if (plexLinked) {
            setPlexLinkStatus('Plex account linked successfully.', 'success', {
              force: true,
            });
          } else {
            setPlexLinkStatus(
              'Link your Plex account so we can enable PayPal checkout and invites.',
              'info'
            );
          }
          closePlexAuthWindow();
        }
      }

      function updateMembershipStatusMessage(
        donor,
        {
          showSubscriptionCta,
          nextInviteMessage = '',
          cooldownActive = false,
          refreshError = '',
          plexLinked = false,
          emailVerified = true,
        } = {}
      ) {
        if (!memberStatusMessage) {
          return;
        }

        const normalizedRefreshError =
          typeof refreshError === 'string' ? refreshError.trim() : '';
        if (normalizedRefreshError) {
          setStatusText(memberStatusMessage, normalizedRefreshError, 'error');
          memberStatusMessage.classList.add('small');
          return;
        }

        if (donor && !emailVerified) {
          setStatusText(
            memberStatusMessage,
            'Check your inbox for the verification email to unlock your dashboard.',
            'error'
          );
          memberStatusMessage.classList.add('small');
          return;
        }

        const normalizedStatus = (donor && donor.status
          ? donor.status
          : 'pending'
        ).toLowerCase();
        const lastPayment = donor && donor.lastPaymentAt ? formatDate(donor.lastPaymentAt) : '';
        const accessExpiresAt = donor ? donor.accessExpiresAt : null;
        const trialCountdown = getTrialCountdownLabel(accessExpiresAt);
        const trialExpiresOn = formatDateTime(accessExpiresAt);

        let tone = 'info';
        let message = '';

        switch (normalizedStatus) {
          case 'active':
            tone = 'success';
            if (nextInviteMessage && cooldownActive) {
              message = `${nextInviteMessage} We'll refresh this dashboard automatically when your next referral unlocks so you can share it or regenerate your own link if you've lost access.`;
            } else if (nextInviteMessage) {
              message = `Your subscription is active. ${nextInviteMessage} Share a referral invite below when it unlocks—or regenerate your own link if you've lost access.`;
            } else if (lastPayment) {
              message = `Your subscription is active. Last payment recorded ${lastPayment}. Share a referral invite below when you're ready, and only regenerate your own link if you've lost access.`;
            } else {
              message = 'Your subscription is active. Share referral invites below to welcome someone new, and only regenerate your own link if you have lost access.';
            }
            break;
          case 'trial':
            tone = 'info';
            if (trialCountdown) {
              message = `Your 7-day trial is active. Access expires in ${trialCountdown}.`;
            } else if (trialExpiresOn) {
              message = `Your 7-day trial is active. Access expires on ${trialExpiresOn}.`;
            } else {
              message = 'Your 7-day trial is active.';
            }
            if (showSubscriptionCta) {
              message += ' Start a subscription above to keep streaming without interruption.';
            } else {
              message += ' Add your subscription ID below to keep streaming without interruption.';
            }
            break;
          case 'trial_expired':
            tone = 'error';
            if (trialExpiresOn) {
              message = `Your free trial ended on ${trialExpiresOn}.`;
            } else {
              message = 'Your free trial has ended.';
            }
            if (showSubscriptionCta) {
              message += ' Start a subscription above to continue access.';
            } else {
              message += ' Add your subscription ID below to restore access.';
            }
            break;
          case 'pending':
            tone = 'info';
            if (!donor || !donor.subscriptionId) {
              if (!plexLinked) {
                message =
                  'Link your Plex account above to unlock subscription checkout or paste your subscription ID once you have it.';
              } else if (showSubscriptionCta) {
                message =
                  'Start your subscription above or paste an existing subscription ID below to activate your membership.';
              } else {
                message =
                  'Already subscribed? Add your subscription ID below so we can link it to your account.';
              }
            } else {
              message =
                'We are waiting to confirm your first payment. This usually takes just a moment.';
            }
            break;
          case 'cancelled':
            tone = 'error';
            message =
              'Your subscription was canceled. Start a new subscription to regain access.';
            break;
          case 'suspended':
            tone = 'error';
            message =
              'Your subscription is suspended. Update your billing details to resume access.';
            break;
          case 'expired':
            tone = 'error';
            message =
              'Your subscription expired. Start a new subscription to continue access.';
            break;
          case 'past_due':
            tone = 'error';
            message =
              'Your subscription payment is past due. Update your billing information to avoid interruptions.';
            break;
          default:
            tone = 'info';
            message =
              'Your subscription status is being updated. Contact the server admin if this looks wrong.';
            break;
        }

        setStatusText(memberStatusMessage, message, tone);
        memberStatusMessage.classList.add('small');
      }

      function renderInvite(
        invite,
        limitReached,
        nextInviteAvailableAt,
        { emailVerified = true } = {}
      ) {
        const limitHit = Boolean(limitReached);
        const nextAvailableDate = parseDate(nextInviteAvailableAt);
        const cooldownActive =
          limitHit && nextAvailableDate && nextAvailableDate.getTime() > Date.now();
        const nextInviteMessage = cooldownActive
          ? `Next referral invite available on ${formatDateTime(nextAvailableDate)}.`
          : '';

        if (inviteStatus) {
          if (!emailVerified) {
            setStatusText(
              inviteStatus,
              'Verify your email to unlock referral invites.',
              'info'
            );
          } else {
            setStatusText(inviteStatus, '');
          }
        }

        if (inviteForm) {
          if (limitHit) {
            inviteForm.classList.add('hidden');
          } else {
            inviteForm.classList.remove('hidden');
          }
        }

          if (!invite || !invite.inviteUrl) {
            inviteReady.classList.add('hidden');
            inviteLinkEl.removeAttribute('href');
            inviteLinkEl.textContent = '';
            inviteEmailDisplay.textContent = '';
            inviteCreated.textContent = '';
          if (cooldownActive && nextInviteMessage) {
            inviteDescription.textContent =
              `${nextInviteMessage} We'll refresh this dashboard automatically when you're eligible to send another referral invite.`;
          } else {
            inviteDescription.textContent = limitHit
              ? 'This month’s referral invite has already been used. Contact the server admin if you lost access and need the link restored.'
              : 'Active subscribers can send one referral invite each month. Use the form below when you are ready to share it—and only regenerate your own link if you have lost access.';
          }
          if (inviteSubmit) {
            if (cooldownActive) {
              inviteSubmit.textContent = 'Referral invite cooling down…';
            } else {
              inviteSubmit.textContent = limitHit
                ? 'Referral invite already sent'
                : 'Send referral invite';
            }
            inviteSubmit.disabled = limitHit;
          }
          return;
        }

          inviteReady.classList.remove('hidden');
          inviteLinkEl.href = invite.inviteUrl;
          inviteLinkEl.textContent = invite.inviteUrl;
        inviteEmailDisplay.textContent = invite.recipientEmail
          ? `Delivering to ${invite.recipientEmail}`
          : '';
        inviteCreated.textContent = invite.createdAt
          ? `Created ${formatDate(invite.createdAt)}`
          : '';
        if (cooldownActive && nextInviteMessage) {
          inviteDescription.textContent =
            `${nextInviteMessage} We'll refresh this dashboard automatically when the referral cooldown ends.`;
        } else {
          inviteDescription.textContent = limitHit
            ? 'Referral invite ready! Reach out to the server admin if you lost access and need the link refreshed.'
            : 'Referral invite ready! Share the link below with your recipient—only follow it yourself if you’re restoring access.';
        }
        if (inviteSubmit) {
          if (cooldownActive) {
            inviteSubmit.textContent = 'Referral invite cooling down…';
          } else {
            inviteSubmit.textContent = limitHit
              ? 'Referral invite already sent'
              : 'Send another referral invite';
          }
          inviteSubmit.disabled = limitHit;
        }
      }

      function setStepState(stepEl, state) {
        if (!stepEl) {
          return;
        }
        const allowed = new Set(['complete', 'current', 'upcoming']);
        const normalized = allowed.has(state) ? state : 'upcoming';
        stepEl.dataset.state = normalized;
        const numberEl = stepEl.querySelector('.step-number');
        if (numberEl && numberEl.dataset && numberEl.dataset.stepNumber) {
          if (normalized === 'complete') {
            numberEl.textContent = '✓';
          } else {
            numberEl.textContent = numberEl.dataset.stepNumber;
          }
        }
      }

      function updateOnboarding(
        data,
        {
          showSubscriptionCta,
          inviteCooldownActive = false,
          nextInviteMessage = '',
          emailVerified = true,
        } = {}
      ) {
        if (!onboardingPanel) {
          return;
        }

        const donor = data && data.donor ? data.donor : null;
        if (donor && !emailVerified) {
          setElementVisibility(onboardingPanel, true);
          if (stepPlex) {
            setStepState(stepPlex, 'upcoming');
          }
          if (stepSubscription) {
            setStepState(stepSubscription, 'upcoming');
          }
          if (stepInvite) {
            setStepState(stepInvite, 'upcoming');
          }
          const verificationNote =
            'Verify your email from the link we sent to unlock the rest of your setup steps.';
          if (stepPlexNote) {
            stepPlexNote.textContent = verificationNote;
          }
          if (stepSubscriptionNote) {
            stepSubscriptionNote.textContent = verificationNote;
          }
          if (stepInviteNote) {
            stepInviteNote.textContent = verificationNote;
          }
          return;
        }

        const normalizedStatus = donor && donor.status
          ? donor.status.toLowerCase()
          : 'pending';
        const isTrial = normalizedStatus === 'trial';
        const isTrialExpired = normalizedStatus === 'trial_expired';
        const subscriptionComplete = normalizedStatus === 'active';
        const subscriptionStarted = Boolean(donor && donor.subscriptionId) || isTrial;
        const plexLinked = Boolean(donor && donor.plexLinked);
        const plexLinkPending = Boolean(
          data &&
            data.plexLink &&
            typeof data.plexLink.pending === 'boolean' &&
            data.plexLink.pending
        );
        const accessExpiresAt = donor ? donor.accessExpiresAt : null;
        const trialCountdown = getTrialCountdownLabel(accessExpiresAt);
        const trialExpiresOn = formatDateTime(accessExpiresAt);
          const inviteReadyState = Boolean(
            data && data.invite && data.invite.inviteUrl
          );
        const inviteLimitReached = Boolean(data && data.inviteLimitReached);
        const allComplete = plexLinked && subscriptionComplete && inviteReadyState;

        if (allComplete) {
          setElementVisibility(onboardingPanel, false);
          return;
        }

        setElementVisibility(onboardingPanel, true);

        const steps = [
          { el: stepPlex, complete: plexLinked },
          { el: stepSubscription, complete: subscriptionComplete },
          { el: stepInvite, complete: inviteReadyState },
        ];

        let currentAssigned = false;
        for (const step of steps) {
          if (!step.el) {
            continue;
          }
          if (step.complete) {
            setStepState(step.el, 'complete');
          } else if (!currentAssigned) {
            setStepState(step.el, 'current');
            currentAssigned = true;
          } else {
            setStepState(step.el, 'upcoming');
          }
        }

        if (stepPlexNote) {
          if (plexLinked) {
            if (subscriptionComplete) {
              stepPlexNote.textContent =
                'Plex account verified—time to send your referral invite!';
            } else {
              stepPlexNote.textContent =
                'Plex account verified—head to the next step to start your membership.';
            }
          } else if (plexLinkPending) {
            const countdownLabel =
              data && data.plexLink
                ? getPlexCountdownLabel(data.plexLink.expiresAt)
                : '';
            if (countdownLabel) {
              stepPlexNote.textContent =
                `Plex authentication in progress—finish the prompt before it expires in ${countdownLabel}. We'll refresh this card automatically.`;
            } else {
              stepPlexNote.textContent =
                'Follow the Plex prompt you opened to finish authentication. This card updates automatically.';
            }
          } else {
            stepPlexNote.textContent =
              'Use the button below to launch the Plex authentication prompt and link your streaming account. We will update this step as soon as verification completes.';
          }
        }

        if (stepSubscriptionNote) {
          if (!plexLinked) {
            stepSubscriptionNote.textContent =
              'Finish Plex authentication first—we unlock subscription checkout and linking right after.';
          } else if (isTrial) {
            if (trialCountdown) {
              stepSubscriptionNote.textContent =
                `Free trial active—access expires in ${trialCountdown}. Subscribe before it ends to keep streaming.`;
            } else if (trialExpiresOn) {
              stepSubscriptionNote.textContent =
                `Free trial active until ${trialExpiresOn}. Subscribe before it ends to keep streaming.`;
            } else {
              stepSubscriptionNote.textContent =
                'Free trial active. Start your subscription to keep streaming once it ends.';
            }
          } else if (isTrialExpired) {
            stepSubscriptionNote.textContent =
              'Your trial has ended—start a subscription to restore access.';
          } else if (!subscriptionStarted) {
            if (showSubscriptionCta) {
              stepSubscriptionNote.textContent =
                'Choose your payment method above or paste your subscription ID below to kick off your membership.';
            } else {
              stepSubscriptionNote.textContent =
                'Already supporting the server? Paste your subscription ID below and we will link it automatically.';
            }
          } else if (!subscriptionComplete) {
            stepSubscriptionNote.textContent =
              'We are waiting to confirm your first payment. This usually takes just a moment.';
          } else {
            stepSubscriptionNote.textContent =
              'Subscription active! You are ready for the next step.';
          }
        }

        if (stepInviteNote) {
          if (!plexLinked) {
            stepInviteNote.textContent =
              'Finish Plex authentication and we’ll enable referral invites.';
          } else if (!subscriptionComplete) {
            stepInviteNote.textContent =
              'Referral invites unlock after your subscription is active.';
          } else if (!inviteReadyState) {
            stepInviteNote.textContent =
              'Use the form below to send a referral invite as soon as you are verified. Only regenerate your own link if you have lost access.';
          } else if (inviteLimitReached) {
            if (inviteCooldownActive && nextInviteMessage) {
              stepInviteNote.textContent =
                `${nextInviteMessage} We'll refresh this dashboard automatically when you can send the next referral invite.`;
            } else {
              stepInviteNote.textContent =
                'Your referral invite is ready below. Reach out to the server admin if you lost access and need it refreshed.';
            }
          } else {
            stepInviteNote.textContent =
              'Referral invite ready! Share it with your recipient—only use it yourself if you’re restoring access.';
          }
        }
      }

      function renderDashboard(data) {
        const previouslyAuthenticated = Boolean(
          state.data && state.data.authenticated
        );
        state.data = data;
        showApp();

        const hasAnnouncement =
          data && Object.prototype.hasOwnProperty.call(data, 'announcement');
        const announcementPayload = hasAnnouncement
          ? data.announcement
          : state.announcement;
        renderAnnouncementBanner(announcementPayload);
        renderOverseerrIntegration(data && data.integrations);

        if (!data || !data.authenticated) {
          loginPanel.classList.remove('hidden');
          dashboardPanel.classList.add('hidden');
          setActiveDashboardTab(DASHBOARD_TAB_DEFAULT, { force: true });
          loginForm.reset();
          setStatusText(loginStatus, '');
          setStatusText(memberStatusMessage, '');
          clearInviteCooldownTimer();
          clearPlexLinkPollTimer();
          clearPlexLinkCountdownTimer();
          closePlexAuthWindow();
          state.inviteLimitReached = false;
          state.nextInviteAvailableAt = null;
          state.pendingPlexLink = null;
          plexLinkStatusSticky = false;
          clearPlexLinkStatus({ force: true });
          if (plexLinkButton) {
            plexLinkButton.disabled = false;
            plexLinkButton.classList.remove('hidden');
          }
          if (plexLinkPin) {
            plexLinkPin.classList.add('hidden');
          }
          if (plexLinkPinCode) {
            plexLinkPinCode.textContent = '----';
          }
          if (plexLinkPinExpiry) {
            plexLinkPinExpiry.textContent = '';
          }
          if (forgotPasswordHelp) {
            forgotPasswordHelp.classList.add('hidden');
          }
          if (forgotPasswordLink) {
            forgotPasswordLink.textContent = defaultForgotPasswordLinkText;
            forgotPasswordLink.setAttribute('aria-expanded', 'false');
          }
          if (onboardingPanel) {
            setElementVisibility(onboardingPanel, false);
          }
          if (passwordForm) {
            passwordForm.reset();
          }
          if (passwordStatus) {
            setStatusText(passwordStatus, '');
          }
          if (passwordSave) {
            passwordSave.disabled = false;
          }
          if (profileSubscription) {
            profileSubscription.value = '';
          }
          return;
        }

        loginPanel.classList.add('hidden');
        dashboardPanel.classList.remove('hidden');
        if (!previouslyAuthenticated) {
          setActiveDashboardTab('account', { force: true });
        }

        const donor = data.donor || {};
        const emailVerified = Boolean(donor.emailVerified);
        if (emailVerified) {
          applyPlexLinkState(donor, data.plexLink || null);
        } else {
          clearPlexLinkCountdownTimer();
          clearPlexLinkPollTimer();
          closePlexAuthWindow();
          state.pendingPlexLink = null;
          plexLinkStatusSticky = true;
          if (plexLinkButton) {
            plexLinkButton.disabled = true;
            plexLinkButton.classList.remove('hidden');
          }
          if (plexLinkPin) {
            plexLinkPin.classList.add('hidden');
          }
          if (plexLinkPinCode) {
            plexLinkPinCode.textContent = '----';
          }
          if (plexLinkPinExpiry) {
            plexLinkPinExpiry.textContent = '';
          }
          setPlexLinkStatus(
            'Verify your email address to unlock Plex linking.',
            'info',
            { force: true }
          );
        }
        memberNameEl.textContent = donor.name
          ? `Hi ${donor.name}!`
          : 'Add a display name below so we know how to greet you.';
        memberEmailEl.textContent = donor.email
          ? donor.email
          : 'Set your preferred streaming email under profile settings.';

        const normalizedStatus = (donor.status || 'pending').toLowerCase();
        const plexLinked = Boolean(donor.plexLinked);
        if (memberStatusEl) {
          memberStatusEl.dataset.status = normalizedStatus;
          memberStatusEl.textContent = normalizedStatus || 'pending';
        }

        if (donor.subscriptionId) {
          memberSubscriptionRow.classList.remove('hidden');
          memberSubscriptionId.textContent = donor.subscriptionId;
        } else {
          memberSubscriptionRow.classList.add('hidden');
          memberSubscriptionId.textContent = '';
        }

        if (donor.lastPaymentAt) {
          memberLastPaymentRow.classList.remove('hidden');
          memberLastPayment.textContent = formatDate(donor.lastPaymentAt);
        } else {
          memberLastPaymentRow.classList.add('hidden');
          memberLastPayment.textContent = '';
        }

        const price = formatPrice(
          Number(data.paypal && data.paypal.subscriptionPrice),
          data.paypal && data.paypal.currency
        );
        if (price) {
          memberPlanEl.classList.remove('hidden');
          memberPlanEl.innerHTML = `<span class="label">Monthly support</span><span>${price}</span>`;
        } else {
          memberPlanEl.classList.add('hidden');
          memberPlanEl.innerHTML = '';
        }

        const subscriptionCheckoutEligible = Boolean(
          emailVerified &&
            data.paypal &&
            data.paypal.subscriptionCheckoutAvailable &&
            (!donor.subscriptionId || normalizedStatus !== 'active')
        );
        const showSubscriptionCta = Boolean(
          subscriptionCheckoutEligible && plexLinked
        );

        const limitReached = Boolean(data.inviteLimitReached);
        state.inviteLimitReached = limitReached;
        const nextInviteAvailableAt = data.nextInviteAvailableAt || null;
        const nextInviteDate = parseDate(nextInviteAvailableAt);
        const nextInviteInFuture =
          nextInviteDate && nextInviteDate.getTime() > Date.now();
        const nextInviteMessage = nextInviteInFuture
          ? `Next invite available on ${formatDateTime(nextInviteDate)}.`
          : '';
        const inviteCooldownActive = limitReached && nextInviteInFuture;
        scheduleInviteCooldownRefresh(
          inviteCooldownActive ? nextInviteAvailableAt : null
        );

        updateMembershipStatusMessage(donor, {
          showSubscriptionCta,
          nextInviteMessage,
          cooldownActive: inviteCooldownActive,
          refreshError:
            data.paypal && typeof data.paypal.refreshError === 'string'
              ? data.paypal.refreshError
              : '',
          plexLinked,
          emailVerified,
        });
        updateOnboarding(data, {
          showSubscriptionCta,
          inviteCooldownActive,
          nextInviteMessage,
          emailVerified,
        });

        const accessExpiresAt = donor ? donor.accessExpiresAt : null;
        const trialCountdownLabel = getTrialCountdownLabel(accessExpiresAt);
        const trialExpiresLabel = formatDateTime(accessExpiresAt);
        const trialDaysRemaining = getTrialDaysRemaining(accessExpiresAt);
        const trialExpiresDate = parseDate(accessExpiresAt);
        const trialHasTimeRemaining = Boolean(
          trialExpiresDate && trialExpiresDate.getTime() > Date.now()
        );

        if (trialPanel) {
          const shouldShowTrialPanel =
            normalizedStatus === 'trial' && trialHasTimeRemaining;
          setElementVisibility(trialPanel, shouldShowTrialPanel);

          if (shouldShowTrialPanel) {
            const normalizedDaysRemaining =
              typeof trialDaysRemaining === 'number'
                ? Math.max(0, trialDaysRemaining)
                : 0;
            if (trialDaysRemainingValue) {
              trialDaysRemainingValue.textContent = `${normalizedDaysRemaining}`;
            }
            if (trialDaysLabel) {
              trialDaysLabel.textContent =
                normalizedDaysRemaining === 1
                  ? 'day remaining'
                  : 'days remaining';
            }
            if (trialEndDate) {
              trialEndDate.textContent = trialExpiresLabel || '—';
            }
            if (trialCountdownDetail) {
              if (trialCountdownLabel) {
                if (normalizedDaysRemaining === 0) {
                  trialCountdownDetail.textContent = `Less than a day remaining (${trialCountdownLabel}).`;
                } else {
                  trialCountdownDetail.textContent = `Approximately ${trialCountdownLabel} left in your trial.`;
                }
              } else if (trialHasTimeRemaining) {
                trialCountdownDetail.textContent =
                  'Less than a day left in your trial.';
              } else {
                trialCountdownDetail.textContent = '';
              }
            }
          } else {
            if (trialCountdownDetail) {
              trialCountdownDetail.textContent = '';
            }
            if (trialDaysRemainingValue) {
              trialDaysRemainingValue.textContent = '0';
            }
            if (trialDaysLabel) {
              trialDaysLabel.textContent = 'days remaining';
            }
            if (trialEndDate) {
              trialEndDate.textContent = '—';
            }
          }
        }

        if (subscriptionCta) {
          let subscriptionButtonVisible = false;
          let subscriptionButtonAvailable = false;
          let subscriptionNoteMessage = '';
          let subscriptionNoteTone = 'info';

          if (subscriptionButton) {
            subscriptionButton.textContent = defaultSubscriptionButtonLabel;

            if (!emailVerified) {
              subscriptionButtonVisible = true;
              subscriptionButtonAvailable = false;
              subscriptionNoteMessage =
                'Verify your email to unlock subscription checkout.';
            } else if (showSubscriptionCta) {
              subscriptionButtonVisible = true;
              subscriptionButtonAvailable = true;
              subscriptionNoteMessage = 'Opens PayPal checkout in a new tab.';
            } else if (subscriptionCheckoutEligible && !plexLinked) {
              subscriptionButtonVisible = false;
              subscriptionButtonAvailable = false;
              subscriptionNoteMessage = '';
            } else {
              subscriptionButtonVisible = false;
              subscriptionButtonAvailable = false;
              subscriptionNoteMessage = '';
              subscriptionNoteTone = '';
            }

            subscriptionButton.classList.toggle(
              'hidden',
              !subscriptionButtonVisible
            );
            subscriptionButton.disabled = !subscriptionButtonAvailable;
            subscriptionButton.dataset.available = subscriptionButtonAvailable
              ? 'true'
              : 'false';

            if (subscriptionNote) {
              setStatusText(
                subscriptionNote,
                subscriptionNoteMessage,
                subscriptionNoteTone
              );
              if (subscriptionNoteMessage) {
                subscriptionNote.classList.add('small');
              } else {
                subscriptionNote.classList.remove('small');
              }
            }
          }

          let trialButtonHidden = true;
          let trialButtonAvailable = false;
          let trialStatusMessage = '';
          let trialStatusTone = '';

          if (trialButton) {
            trialButton.textContent = defaultTrialButtonLabel;
          }

          if (trialButton || trialStatus) {
            if (!emailVerified) {
              trialButtonHidden = false;
              trialButtonAvailable = false;
              trialStatusMessage =
                'Verify your email to unlock the free trial.';
              trialStatusTone = 'info';
            } else if (!plexLinked) {
              trialButtonHidden = false;
              trialButtonAvailable = false;
              trialStatusMessage =
                'Link your Plex account above to unlock both subscription and trial options.';
              trialStatusTone = 'info';
            } else if (normalizedStatus === 'active') {
              trialButtonHidden = true;
              trialButtonAvailable = false;
              trialStatusMessage = '';
            } else if (normalizedStatus === 'trial') {
              trialButtonHidden = false;
              trialButtonAvailable = false;
              if (trialCountdownLabel) {
                trialStatusMessage = `Trial active! Access expires in ${trialCountdownLabel}.`;
              } else if (trialExpiresLabel) {
                trialStatusMessage = `Trial active! Access expires on ${trialExpiresLabel}.`;
              } else {
                trialStatusMessage = 'Trial active! Access expires soon.';
              }
              trialStatusTone = 'success';
            } else if (normalizedStatus === 'trial_expired') {
              trialButtonHidden = false;
              trialButtonAvailable = false;
              if (trialExpiresLabel) {
                trialStatusMessage = `Trial ended on ${trialExpiresLabel}. Start a subscription to continue.`;
              } else {
                trialStatusMessage =
                  'Trial ended. Start a subscription to continue.';
              }
              trialStatusTone = 'error';
            } else {
              trialButtonHidden = false;
              trialButtonAvailable = true;
              trialStatusMessage =
                'Try the server free for 7 days—no payment required.';
              trialStatusTone = 'info';
            }
          }

          if (trialButton) {
            trialButton.classList.toggle('hidden', trialButtonHidden);
            trialButton.disabled = !trialButtonAvailable;
            trialButton.dataset.available = trialButtonAvailable ? 'true' : 'false';
          }

          if (trialStatus) {
            setStatusText(trialStatus, trialStatusMessage, trialStatusTone);
            if (trialStatusMessage) {
              trialStatus.classList.add('small');
            } else {
              trialStatus.classList.remove('small');
            }
          }

          // Show Stripe checkout button for new subscriptions
          if (stripeCheckoutDashboardButton) {
            if (showSubscriptionCta && emailVerified) {
              stripeCheckoutDashboardButton.classList.remove('hidden');
              stripeCheckoutDashboardButton.disabled = false;
            } else {
              stripeCheckoutDashboardButton.classList.add('hidden');
            }
          }

          // Show Stripe billing portal button for Stripe customers
          if (stripeBillingPortalButton) {
            const hasStripeCustomer = Boolean(donor && donor.stripeCustomerId);
            if (hasStripeCustomer) {
              stripeBillingPortalButton.classList.remove('hidden');
              if (stripePortalStatus) {
                stripePortalStatus.classList.add('hidden');
              }
            } else {
              stripeBillingPortalButton.classList.add('hidden');
              if (stripePortalStatus) {
                stripePortalStatus.classList.add('hidden');
              }
            }
          }

          const subscriptionButtonVisibleNow = Boolean(
            subscriptionButton &&
              !subscriptionButton.classList.contains('hidden')
          );
          const stripeCheckoutVisible = Boolean(
            stripeCheckoutDashboardButton &&
              !stripeCheckoutDashboardButton.classList.contains('hidden')
          );
          const trialVisible = Boolean(
            trialButton && !trialButton.classList.contains('hidden')
          );
          const trialMessageVisible = Boolean(
            trialStatus && trialStatus.textContent.trim().length > 0
          );
          const stripeBillingPortalVisible = Boolean(
            stripeBillingPortalButton &&
              !stripeBillingPortalButton.classList.contains('hidden')
          );

          const shouldShowSubscriptionCta =
            subscriptionButtonVisibleNow || stripeCheckoutVisible || trialVisible || trialMessageVisible || stripeBillingPortalVisible;

          setElementVisibility(subscriptionCta, shouldShowSubscriptionCta);
        }

        profileEmail.value = donor.email || '';
        profileName.value = donor.name || '';
        if (profileSubscription) {
          profileSubscription.value = donor.subscriptionId || '';
        }
        if (profileEmail) {
          profileEmail.disabled = !emailVerified;
        }
        if (profileName) {
          profileName.disabled = !emailVerified;
        }
        if (profileSubscription) {
          profileSubscription.disabled = !emailVerified;
        }
        if (profileSave) {
          profileSave.disabled = !emailVerified;
        }
        if (passwordForm) {
          passwordForm.reset();
        }
        if (passwordStatus) {
          setStatusText(passwordStatus, '');
        }
        if (passwordGuidance) {
          if (!emailVerified) {
            passwordGuidance.textContent =
              'Verify your email to enable password updates.';
          } else {
            passwordGuidance.textContent = donor.hasPassword
              ? 'Update your dashboard password to keep your account secure.'
              : 'Set a password so you can return to the dashboard anytime.';
          }
        }
        if (passwordCurrentRow) {
          if (donor.hasPassword) {
            passwordCurrentRow.classList.remove('hidden');
          } else {
            passwordCurrentRow.classList.add('hidden');
          }
        }
        if (passwordCurrent) {
          passwordCurrent.disabled = !emailVerified || !donor.hasPassword;
          passwordCurrent.required = Boolean(emailVerified && donor.hasPassword);
        }
        if (passwordNew) {
          passwordNew.disabled = !emailVerified;
        }
        if (passwordConfirm) {
          passwordConfirm.disabled = !emailVerified;
        }
        if (passwordSave) {
          passwordSave.disabled = !emailVerified;
        }
        inviteEmail.value = donor.email || '';
        if (supportNameInput) {
          const preferredName = donor.name || donor.email || '';
          if (!supportNameInput.value) {
            supportNameInput.value = preferredName;
          }
          supportNameInput.placeholder = preferredName || 'Display name';
        }
        if (state.support.donorId !== donor.id) {
          state.support.donorId = donor.id;
          state.support.threads = [];
          state.support.activeThreadId = null;
          state.support.replyDrafts = {};
          loadSupportThreads({ silent: true });
        }

        renderInvite(data.invite, limitReached, nextInviteAvailableAt, {
          emailVerified,
        });

        const inviteBlocked = !emailVerified || normalizedStatus !== 'active' || limitReached;
        if (inviteSubmit) {
          inviteSubmit.disabled = inviteBlocked;
        }
        if (inviteEmail) {
          inviteEmail.disabled = inviteBlocked;
        }
        if (inviteNote) {
          inviteNote.disabled = inviteBlocked;
        }

        if (!emailVerified) {
          inviteDescription.textContent =
            'Verify your email to unlock referral invites.';
        } else if (inviteBlocked && !limitReached) {
          inviteDescription.textContent = showSubscriptionCta
            ? 'Start your subscription to unlock referral invites.'
            : 'Referral invites unlock once your subscription is active.';
        }

        const identifier = donor.name || donor.email || donor.subscriptionId || '';
        if (identifier) {
          document.title = `Plex Dashboard • ${identifier}`;
        }
      }

      async function openDashboardSubscriptionCheckout() {
        if (!subscriptionButton || subscriptionButton.dataset.available !== 'true') {
          return;
        }

        subscriptionButton.disabled = true;
        subscriptionButton.textContent = 'Opening PayPal…';
        setStatusText(
          subscriptionNote,
          'Opening PayPal checkout in a new tab…',
          'info'
        );
        subscriptionNote.classList.add('small');

        const payload = {};
        const emailValue = profileEmail ? profileEmail.value.trim() : '';
        const nameValue = profileName ? profileName.value.trim() : '';
        if (emailValue) {
          payload.email = emailValue;
        }
        if (nameValue) {
          payload.name = nameValue;
        }

        const requestInit = {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        };

        let checkoutWindow = null;
        try {
          checkoutWindow = window.open('', '_blank');
          if (checkoutWindow) {
            try {
              checkoutWindow.opener = null;
            } catch (err) {
              // Ignore browsers that prevent direct assignment.
            }
          }
        } catch (err) {
          checkoutWindow = null;
        }

        try {
          const response = await sessionFetch('/api/customer/paypal-checkout', requestInit);
          let data;
          try {
            data = await response.json();
          } catch (err) {
            data = {};
          }

          updateSessionTokenFromResponse(data);

          if (!response.ok) {
            throw new Error(data.error || 'Unable to start PayPal checkout.');
          }

          if (data.approvalUrl) {
            let opened = false;
            if (checkoutWindow) {
              checkoutWindow.location = data.approvalUrl;
              opened = true;
            } else {
              const fallbackWindow = window.open(data.approvalUrl, '_blank');
              if (fallbackWindow) {
                opened = true;
                checkoutWindow = fallbackWindow;
                try {
                  fallbackWindow.opener = null;
                } catch (err) {
                  // Ignore browsers that prevent direct assignment.
                }
              }
            }

            if (!opened) {
              throw new Error(
                'Your browser blocked the PayPal checkout window. Allow pop-ups and try again.'
              );
            }
            setStatusText(
              subscriptionNote,
              'Follow the steps in the PayPal tab to complete your subscription.',
              'success'
            );
            subscriptionNote.classList.add('small');
          } else {
            throw new Error('PayPal did not return a checkout URL.');
          }
        } catch (err) {
          setStatusText(subscriptionNote, err.message, 'error');
          subscriptionNote.classList.add('small');
          if (checkoutWindow) {
            try {
              checkoutWindow.close();
            } catch (closeErr) {
              // Ignore close errors.
            }
          }
        } finally {
          subscriptionButton.disabled = false;
          subscriptionButton.textContent = defaultSubscriptionButtonLabel;
        }
      }

      async function fetchSession(options = {}) {
        const silent = options && options.silent;
        if (!silent) {
          showLoading();
        }
        try {
          const response = await sessionFetch('/api/customer/session');
          const payload = await response.json();
          updateSessionTokenFromResponse(payload);
          renderDashboard(payload);
        } catch (err) {
          showError(err.message);
        }
      }

      if (forgotPasswordLink) {
        forgotPasswordLink.addEventListener('click', (event) => {
          event.preventDefault();
          if (!forgotPasswordHelp) {
            return;
          }
          const isHidden = forgotPasswordHelp.classList.contains('hidden');
          if (isHidden) {
            forgotPasswordHelp.classList.remove('hidden');
            forgotPasswordLink.setAttribute('aria-expanded', 'true');
            forgotPasswordLink.textContent = 'Hide password help';
          } else {
            forgotPasswordHelp.classList.add('hidden');
            forgotPasswordLink.setAttribute('aria-expanded', 'false');
            forgotPasswordLink.textContent = defaultForgotPasswordLinkText;
          }
        });
      }

      if (changePasswordButton) {
        changePasswordButton.addEventListener('click', () => {
          setActiveDashboardTab('account');
          if (passwordPanel) {
            passwordPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
          window.setTimeout(() => {
            if (passwordNew) {
              try {
                passwordNew.focus();
              } catch (err) {
                // Ignore focus errors.
              }
            }
          }, 200);
        });
      }

      if (passwordForm) {
        passwordForm.addEventListener('submit', async (event) => {
          event.preventDefault();
          if (!passwordSave) {
            return;
          }
          setStatusText(passwordStatus, 'Saving…', 'info');
          passwordSave.disabled = true;
          const payload = {
            currentPassword: passwordCurrent ? passwordCurrent.value : '',
            newPassword: passwordNew ? passwordNew.value : '',
            confirmPassword: passwordConfirm ? passwordConfirm.value : '',
          };

          try {
            const response = await sessionFetch('/api/customer/password', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });
            let responseBody;
            try {
              responseBody = await response.json();
            } catch (err) {
              responseBody = {};
            }
            updateSessionTokenFromResponse(responseBody);
            if (!response.ok) {
              throw new Error(responseBody.error || 'Failed to update password');
            }
            renderDashboard(responseBody);
            setStatusText(
              passwordStatus,
              'Password updated successfully.',
              'success'
            );
            if (passwordForm) {
              passwordForm.reset();
            }
          } catch (err) {
            setStatusText(passwordStatus, err.message, 'error');
          } finally {
            if (passwordSave) {
              passwordSave.disabled = false;
            }
          }
        });
      }

      loginForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        const email = loginEmail.value.trim();
        const password = loginPassword.value;

        if (!email || !password) {
          setStatusText(
            loginStatus,
            'Enter both your email and password to continue.',
            'error'
          );
          return;
        }

        setStatusText(loginStatus, 'Signing in…', 'info');
        loginButton.disabled = true;
        try {
          const response = await sessionFetch('/api/customer/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              email,
              password,
            }),
          });
          const payload = await response.json();
          updateSessionTokenFromResponse(payload);
          if (!response.ok) {
            throw new Error(payload.error || 'Unable to sign in');
          }
          setStatusText(loginStatus, 'Signed in successfully!', 'success');
          renderDashboard(payload);
          loginPassword.value = '';
        } catch (err) {
          setStatusText(loginStatus, err.message, 'error');
        } finally {
          loginButton.disabled = false;
        }
      });

      logoutButton.addEventListener('click', async () => {
        logoutButton.disabled = true;
        try {
          await sessionFetch('/api/customer/logout', { method: 'POST' });
          renderDashboard({ authenticated: false });
        } catch (err) {
          // ignore logout errors and show login anyway
          renderDashboard({ authenticated: false });
        } finally {
          setSessionToken(null);
          logoutButton.disabled = false;
        }
      });

      if (subscriptionButton) {
        subscriptionButton.addEventListener('click', async (event) => {
          event.preventDefault();
          if (subscriptionButton.disabled || subscriptionButton.dataset.available !== 'true') {
            return;
          }
          await openDashboardSubscriptionCheckout();
        });
      }

      if (stripeBillingPortalButton) {
        stripeBillingPortalButton.addEventListener('click', async (event) => {
          event.preventDefault();
          if (stripeBillingPortalButton.disabled) {
            return;
          }

          stripeBillingPortalButton.disabled = true;
          stripeBillingPortalButton.textContent = 'Opening billing portal…';

          if (stripePortalStatus) {
            stripePortalStatus.classList.remove('hidden');
            setStatusText(stripePortalStatus, 'Opening Stripe billing portal in a new tab…', 'info');
          }

          try {
            const response = await sessionFetch('/api/customer/stripe-billing-portal', {
              method: 'POST',
            });

            const payload = await response.json();
            if (!response.ok) {
              throw new Error(payload.error || 'Failed to access billing portal');
            }

            if (payload.portalUrl) {
              const opened = window.open(payload.portalUrl, '_blank', 'noopener,noreferrer');
              if (opened) {
                stripeBillingPortalButton.textContent = 'Manage Stripe Billing';
                if (stripePortalStatus) {
                  setStatusText(
                    stripePortalStatus,
                    'Billing portal opened. Manage your subscription in the new tab.',
                    'success'
                  );
                }
              } else {
                throw new Error('Please allow popups to access the billing portal.');
              }
            } else {
              throw new Error('No billing portal URL received.');
            }
          } catch (err) {
            stripeBillingPortalButton.textContent = 'Manage Stripe Billing';
            if (stripePortalStatus) {
              setStatusText(stripePortalStatus, err.message, 'error');
            }
          } finally {
            stripeBillingPortalButton.disabled = false;
          }
        });
      }

      if (stripeCheckoutDashboardButton) {
        stripeCheckoutDashboardButton.addEventListener('click', async (event) => {
          event.preventDefault();
          if (stripeCheckoutDashboardButton.disabled) {
            return;
          }

          stripeCheckoutDashboardButton.disabled = true;
          const originalText = stripeCheckoutDashboardButton.textContent;
          stripeCheckoutDashboardButton.textContent = 'Opening Stripe checkout…';

          if (subscriptionNote) {
            setStatusText(subscriptionNote, 'Opening Stripe checkout in a new tab…', 'info');
            subscriptionNote.classList.add('small');
          }

          try {
            const response = await sessionFetch('/api/customer/stripe-checkout', {
              method: 'POST',
            });

            const payload = await response.json();
            if (!response.ok) {
              throw new Error(payload.error || 'Failed to start Stripe checkout');
            }

            if (payload.checkoutUrl) {
              window.location.href = payload.checkoutUrl;
            } else {
              throw new Error('No Stripe checkout URL received.');
            }
          } catch (err) {
            stripeCheckoutDashboardButton.textContent = originalText;
            stripeCheckoutDashboardButton.disabled = false;
            if (subscriptionNote) {
              setStatusText(subscriptionNote, err.message, 'error');
              subscriptionNote.classList.add('small');
            }
          }
        });
      }

      if (trialButton) {
        trialButton.addEventListener('click', async (event) => {
          event.preventDefault();
          if (trialButton.disabled || trialButton.dataset.available !== 'true') {
            return;
          }

          trialButton.disabled = true;
          trialButton.dataset.available = 'false';
          trialButton.textContent = 'Starting trial…';

          if (trialStatus) {
            setStatusText(trialStatus, 'Activating your trial…', 'info');
            trialStatus.classList.add('small');
          }

          try {
            const response = await sessionFetch('/api/customer/trial', {
              method: 'POST',
            });
            let payload;
            try {
              payload = await response.json();
            } catch (err) {
              payload = {};
            }
            updateSessionTokenFromResponse(payload);
            if (!response.ok) {
              throw new Error(payload.error || 'Unable to start a trial.');
            }
            if (trialStatus) {
              setStatusText(
                trialStatus,
                'Trial activated! Refreshing your dashboard…',
                'success'
              );
              trialStatus.classList.add('small');
            }
            renderDashboard(payload);
          } catch (err) {
            if (trialStatus) {
              setStatusText(trialStatus, err.message, 'error');
              trialStatus.classList.add('small');
            }
            trialButton.disabled = false;
            trialButton.dataset.available = 'true';
          } finally {
            trialButton.textContent = defaultTrialButtonLabel;
          }
        });
      }

      if (plexLinkButton) {
        plexLinkButton.addEventListener('click', async () => {
          if (plexLinkButton.disabled) {
            return;
          }

          setPlexLinkStatus('Starting Plex authentication…', 'info', {
            force: true,
          });
          plexLinkButton.disabled = true;
          clearPlexLinkPollTimer();
          clearPlexLinkCountdownTimer();
          closePlexAuthWindow();
          state.pendingPlexLink = null;

          let authWindow = null;
          try {
            authWindow = window.open('', '_blank');
            if (authWindow) {
              try {
                authWindow.opener = null;
              } catch (err) {
                // Ignore browsers that prevent direct assignment.
              }
            }
          } catch (err) {
            authWindow = null;
          }

          let responseData = null;
          try {
            const response = await sessionFetch('/api/customer/plex/link/start', {
              method: 'POST',
            });
            try {
              responseData = await response.json();
            } catch (err) {
              responseData = {};
            }
            updateSessionTokenFromResponse(responseData);
            if (!response.ok) {
              throw new Error(
                (responseData && responseData.error) ||
                  'Failed to start Plex authentication. Try again shortly.'
              );
            }

            renderDashboard(responseData);

            const authUrl =
              responseData &&
              responseData.plexLink &&
              responseData.plexLink.authUrl
                ? responseData.plexLink.authUrl
                : '';

            if (authUrl) {
              let opened = false;
              if (authWindow) {
                authWindow.location = authUrl;
                plexLinkAuthWindow = authWindow;
                opened = true;
              } else {
                const fallbackWindow = window.open(authUrl, '_blank');
                if (fallbackWindow) {
                  opened = true;
                  plexLinkAuthWindow = fallbackWindow;
                  try {
                    fallbackWindow.opener = null;
                  } catch (err) {
                    // Ignore browsers that prevent direct assignment.
                  }
                }
              }

              if (!opened) {
                throw new Error(
                  'Your browser blocked the Plex authentication window. Allow pop-ups and try again.'
                );
              }
            } else if (authWindow) {
              try {
                authWindow.close();
              } catch (err) {
                // Ignore window close errors.
              }
              plexLinkAuthWindow = null;
            }
          } catch (err) {
            if (authWindow) {
              try {
                authWindow.close();
              } catch (closeErr) {
                // Ignore window close errors.
              }
            }
            plexLinkAuthWindow = null;
            setPlexLinkStatus(err.message || 'Failed to start Plex authentication.', 'error', {
              sticky: true,
              force: true,
            });
            plexLinkButton.disabled = false;
            plexLinkButton.classList.remove('hidden');
            clearPlexLinkCountdownTimer();
            clearPlexLinkPollTimer();
            state.pendingPlexLink = null;
            if (plexLinkPin) {
              plexLinkPin.classList.add('hidden');
            }
            if (plexLinkPinCode) {
              plexLinkPinCode.textContent = '----';
            }
            if (plexLinkPinExpiry) {
              plexLinkPinExpiry.textContent = '';
            }
          }
        });
      }

      if (supportToggle && supportContainer) {
        supportToggle.addEventListener('click', async () => {
          await setSupportPanelOpen(!supportPanelOpen);
        });
      }

      if (supportForm) {
        supportForm.addEventListener('submit', async (event) => {
          event.preventDefault();
          if (supportSubmit) {
            supportSubmit.disabled = true;
          }
          setStatusText(supportStatus, 'Sending support request…', 'info');
          try {
            const response = await sessionFetch('/api/customer/support', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                subject: supportSubjectInput ? supportSubjectInput.value.trim() : '',
                message: supportMessageInput ? supportMessageInput.value.trim() : '',
                displayName: supportNameInput ? supportNameInput.value.trim() : '',
              }),
            });
            const payload = await response.json();
            updateSessionTokenFromResponse(payload);
            if (!response.ok) {
              throw new Error(
                (payload && payload.error) || 'Failed to submit support request.'
              );
            }
            if (supportSubjectInput) {
              supportSubjectInput.value = '';
            }
            if (supportMessageInput) {
              supportMessageInput.value = '';
            }
            setStatusText(
              supportStatus,
              'Support request sent! We will email you when we respond.',
              'success'
            );
            if (payload && payload.thread && payload.thread.request) {
              state.support.activeThreadId = payload.thread.request.id;
            }
            await loadSupportThreads({ silent: true });
          } catch (err) {
            setStatusText(
              supportStatus,
              err && err.message ? err.message : 'Failed to submit support request.',
              'error'
            );
          } finally {
            if (supportSubmit) {
              supportSubmit.disabled = false;
            }
          }
        });
      }

      if (supportReplyForm) {
        supportReplyForm.addEventListener('submit', async (event) => {
          event.preventDefault();
          const activeThreadId = state.support.activeThreadId;
          if (!activeThreadId) {
            setStatusText(
              supportReplyStatus,
              'Select a support request first.',
              'error'
            );
            return;
          }
          const messageValue = supportReplyMessage
            ? supportReplyMessage.value.trim()
            : '';
          if (!messageValue) {
            setStatusText(supportReplyStatus, 'Enter a reply before sending.', 'error');
            return;
          }
          if (supportReplySubmit) {
            supportReplySubmit.disabled = true;
          }
          setStatusText(supportReplyStatus, 'Sending reply…', 'info');
          let replyThreadId = activeThreadId;
          try {
            const response = await sessionFetch(
              `/api/customer/support/${activeThreadId}/replies`,
              {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  message: messageValue,
                  displayName: supportNameInput ? supportNameInput.value.trim() : '',
                }),
              }
            );
            const payload = await response.json();
            updateSessionTokenFromResponse(payload);
            if (!response.ok) {
              throw new Error((payload && payload.error) || 'Failed to send reply.');
            }
            if (payload && payload.thread && payload.thread.request) {
              replyThreadId = payload.thread.request.id;
              state.support.activeThreadId = payload.thread.request.id;
            }
            setStatusText(supportReplyStatus, 'Reply sent!', 'success');
            await loadSupportThreads({ silent: true });
            if (replyThreadId && state.support.replyDrafts) {
              delete state.support.replyDrafts[replyThreadId];
            }
            renderSupportThreadDetail();
          } catch (err) {
            setStatusText(
              supportReplyStatus,
              err && err.message ? err.message : 'Failed to send reply.',
              'error'
            );
          } finally {
            if (supportReplySubmit) {
              supportReplySubmit.disabled = false;
            }
          }
        });
      }

      profileForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        setStatusText(profileStatus, 'Saving…', 'info');
        profileSave.disabled = true;
        try {
          const response = await sessionFetch('/api/customer/profile', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              email: profileEmail.value.trim(),
              name: profileName.value.trim(),
              subscriptionId: profileSubscription
                ? profileSubscription.value.trim()
                : '',
            }),
          });
          const payload = await response.json();
          updateSessionTokenFromResponse(payload);
          if (!response.ok) {
            throw new Error(payload.error || 'Failed to update profile');
          }
          setStatusText(profileStatus, 'Profile updated', 'success');
          renderDashboard(payload);
        } catch (err) {
          setStatusText(profileStatus, err.message, 'error');
        } finally {
          profileSave.disabled = false;
        }
      });

      inviteForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        if (
          inviteSubmit.disabled ||
          (inviteForm && inviteForm.classList.contains('hidden')) ||
          (state.data && state.data.inviteLimitReached)
        ) {
          return;
        }
        setStatusText(inviteStatus, 'Sending referral invite…', 'info');
        inviteSubmit.disabled = true;
        let responseData = null;
        try {
          const response = await sessionFetch('/api/customer/invite', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              email: inviteEmail.value.trim(),
              note: inviteNote.value.trim(),
            }),
          });
          const payload = await response.json();
          responseData = payload;
          updateSessionTokenFromResponse(payload);
          if (!response.ok) {
            if (payload && payload.payload) {
              renderDashboard(payload.payload);
            }
            throw new Error(payload.error || 'Failed to send referral invite');
          }
          setStatusText(
            inviteStatus,
            'Referral invite ready! Share the link below—or follow it yourself if you’re restoring access.',
            'success'
          );
          inviteNote.value = '';
          renderDashboard(payload);
        } catch (err) {
          setStatusText(inviteStatus, err.message, 'error');
        } finally {
          const limitHit = Boolean(
            (responseData && responseData.inviteLimitReached) ||
              (state.data && state.data.inviteLimitReached)
          );
          if (!limitHit) {
            inviteSubmit.disabled = false;
          }
        }
      });

      if (initialVerificationToken) {
        submitVerificationToken(initialVerificationToken);
      } else {
        fetchSession();
      }
    </script>
  </body>
</html>
